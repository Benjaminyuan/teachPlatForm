// Code generated by Prisma (prisma@1.24.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  avalibelTime: (where?: AvalibelTimeWhereInput) => Promise<boolean>;
  invitation: (where?: InvitationWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  parent: (where?: ParentWhereInput) => Promise<boolean>;
  student: (where?: StudentWhereInput) => Promise<boolean>;
  subject: (where?: SubjectWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  avalibelTimes: (args?: {
    where?: AvalibelTimeWhereInput;
    orderBy?: AvalibelTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AvalibelTime>;
  avalibelTimesConnection: (args?: {
    where?: AvalibelTimeWhereInput;
    orderBy?: AvalibelTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AvalibelTimeConnectionPromise;
  invitation: (where: InvitationWhereUniqueInput) => InvitationPromise;
  invitations: (args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Invitation>;
  invitationsConnection: (args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InvitationConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderPromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  parent: (where: ParentWhereUniqueInput) => ParentPromise;
  parents: (args?: {
    where?: ParentWhereInput;
    orderBy?: ParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Parent>;
  parentsConnection: (args?: {
    where?: ParentWhereInput;
    orderBy?: ParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ParentConnectionPromise;
  student: (where: StudentWhereUniqueInput) => StudentPromise;
  students: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Student>;
  studentsConnection: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudentConnectionPromise;
  subjects: (args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Subject>;
  subjectsConnection: (args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubjectConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAvalibelTime: (data: AvalibelTimeCreateInput) => AvalibelTimePromise;
  updateManyAvalibelTimes: (args: {
    data: AvalibelTimeUpdateManyMutationInput;
    where?: AvalibelTimeWhereInput;
  }) => BatchPayloadPromise;
  deleteManyAvalibelTimes: (
    where?: AvalibelTimeWhereInput
  ) => BatchPayloadPromise;
  createInvitation: (data: InvitationCreateInput) => InvitationPromise;
  updateInvitation: (args: {
    data: InvitationUpdateInput;
    where: InvitationWhereUniqueInput;
  }) => InvitationPromise;
  updateManyInvitations: (args: {
    data: InvitationUpdateManyMutationInput;
    where?: InvitationWhereInput;
  }) => BatchPayloadPromise;
  upsertInvitation: (args: {
    where: InvitationWhereUniqueInput;
    create: InvitationCreateInput;
    update: InvitationUpdateInput;
  }) => InvitationPromise;
  deleteInvitation: (where: InvitationWhereUniqueInput) => InvitationPromise;
  deleteManyInvitations: (where?: InvitationWhereInput) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (args: {
    data: OrderUpdateInput;
    where: OrderWhereUniqueInput;
  }) => OrderPromise;
  updateManyOrders: (args: {
    data: OrderUpdateManyMutationInput;
    where?: OrderWhereInput;
  }) => BatchPayloadPromise;
  upsertOrder: (args: {
    where: OrderWhereUniqueInput;
    create: OrderCreateInput;
    update: OrderUpdateInput;
  }) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createParent: (data: ParentCreateInput) => ParentPromise;
  updateParent: (args: {
    data: ParentUpdateInput;
    where: ParentWhereUniqueInput;
  }) => ParentPromise;
  updateManyParents: (args: {
    data: ParentUpdateManyMutationInput;
    where?: ParentWhereInput;
  }) => BatchPayloadPromise;
  upsertParent: (args: {
    where: ParentWhereUniqueInput;
    create: ParentCreateInput;
    update: ParentUpdateInput;
  }) => ParentPromise;
  deleteParent: (where: ParentWhereUniqueInput) => ParentPromise;
  deleteManyParents: (where?: ParentWhereInput) => BatchPayloadPromise;
  createStudent: (data: StudentCreateInput) => StudentPromise;
  updateStudent: (args: {
    data: StudentUpdateInput;
    where: StudentWhereUniqueInput;
  }) => StudentPromise;
  updateManyStudents: (args: {
    data: StudentUpdateManyMutationInput;
    where?: StudentWhereInput;
  }) => BatchPayloadPromise;
  upsertStudent: (args: {
    where: StudentWhereUniqueInput;
    create: StudentCreateInput;
    update: StudentUpdateInput;
  }) => StudentPromise;
  deleteStudent: (where: StudentWhereUniqueInput) => StudentPromise;
  deleteManyStudents: (where?: StudentWhereInput) => BatchPayloadPromise;
  createSubject: (data: SubjectCreateInput) => SubjectPromise;
  updateManySubjects: (args: {
    data: SubjectUpdateManyMutationInput;
    where?: SubjectWhereInput;
  }) => BatchPayloadPromise;
  deleteManySubjects: (where?: SubjectWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  avalibelTime: (
    where?: AvalibelTimeSubscriptionWhereInput
  ) => AvalibelTimeSubscriptionPayloadSubscription;
  invitation: (
    where?: InvitationSubscriptionWhereInput
  ) => InvitationSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  parent: (
    where?: ParentSubscriptionWhereInput
  ) => ParentSubscriptionPayloadSubscription;
  student: (
    where?: StudentSubscriptionWhereInput
  ) => StudentSubscriptionPayloadSubscription;
  subject: (
    where?: SubjectSubscriptionWhereInput
  ) => SubjectSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Day = "SUN" | "MON" | "TUE" | "WED" | "THU" | "FRI" | "SAT";

export type DetailTime = "MORN" | "NOON" | "AFTER";

export type AvalibelTimeOrderByInput =
  | "day_ASC"
  | "day_DESC"
  | "detail_ASC"
  | "detail_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type University = "HUST" | "WHU";

export type Gender = "MALE" | "FEMALE";

export type AuthStatus = "UNCOMMITED" | "AUTHCOMMITED" | "AUTHED";

export type SubjectName = "CHINESE" | "MATH" | "ENGLISH";

export type SubjectOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Level = "MIDDLE" | "MIDDLEHIGH" | "PRIMARY" | "UNI";

export type OrderStatus = "PAIED" | "UNPAIED" | "FINISHED";

export type InvitationStatus = "WAITING" | "AGREED" | "REJECTED";

export type InvitationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OrderOrderByInput =
  | "order_ASC"
  | "order_DESC"
  | "status_ASC"
  | "status_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ParentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address_ASC"
  | "address_DESC"
  | "email_ASC"
  | "email_DESC"
  | "authstatus_ASC"
  | "authstatus_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "lessonTime_ASC"
  | "lessonTime_DESC"
  | "days_ASC"
  | "days_DESC"
  | "pay_ASC"
  | "pay_DESC"
  | "childGender_ASC"
  | "childGender_DESC"
  | "teacherReuqire_ASC"
  | "teacherReuqire_DESC"
  | "childStatus_ASC"
  | "childStatus_DESC";

export type StudentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "name_ASC"
  | "name_DESC"
  | "university_ASC"
  | "university_DESC"
  | "email_ASC"
  | "email_DESC"
  | "Gender_ASC"
  | "Gender_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "authstatus_ASC"
  | "authstatus_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface AvalibelTimeWhereInput {
  day?: Day;
  day_not?: Day;
  day_in?: Day[] | Day;
  day_not_in?: Day[] | Day;
  detail?: DetailTime;
  detail_not?: DetailTime;
  detail_in?: DetailTime[] | DetailTime;
  detail_not_in?: DetailTime[] | DetailTime;
  AND?: AvalibelTimeWhereInput[] | AvalibelTimeWhereInput;
  OR?: AvalibelTimeWhereInput[] | AvalibelTimeWhereInput;
  NOT?: AvalibelTimeWhereInput[] | AvalibelTimeWhereInput;
}

export type InvitationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SubjectWhereInput {
  name?: SubjectName;
  name_not?: SubjectName;
  name_in?: SubjectName[] | SubjectName;
  name_not_in?: SubjectName[] | SubjectName;
  AND?: SubjectWhereInput[] | SubjectWhereInput;
  OR?: SubjectWhereInput[] | SubjectWhereInput;
  NOT?: SubjectWhereInput[] | SubjectWhereInput;
}

export interface InvitationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  stuednt?: StudentWhereInput;
  parents?: ParentWhereInput;
  status?: InvitationStatus;
  status_not?: InvitationStatus;
  status_in?: InvitationStatus[] | InvitationStatus;
  status_not_in?: InvitationStatus[] | InvitationStatus;
  AND?: InvitationWhereInput[] | InvitationWhereInput;
  OR?: InvitationWhereInput[] | InvitationWhereInput;
  NOT?: InvitationWhereInput[] | InvitationWhereInput;
}

export interface StudentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  university?: University;
  university_not?: University;
  university_in?: University[] | University;
  university_not_in?: University[] | University;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  Gender?: Gender;
  Gender_not?: Gender;
  Gender_in?: Gender[] | Gender;
  Gender_not_in?: Gender[] | Gender;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  authstatus?: AuthStatus;
  authstatus_not?: AuthStatus;
  authstatus_in?: AuthStatus[] | AuthStatus;
  authstatus_not_in?: AuthStatus[] | AuthStatus;
  subjects_every?: SubjectWhereInput;
  subjects_some?: SubjectWhereInput;
  subjects_none?: SubjectWhereInput;
  avalible_every?: AvalibelTimeWhereInput;
  avalible_some?: AvalibelTimeWhereInput;
  avalible_none?: AvalibelTimeWhereInput;
  invitations_every?: InvitationWhereInput;
  invitations_some?: InvitationWhereInput;
  invitations_none?: InvitationWhereInput;
  order_every?: OrderWhereInput;
  order_some?: OrderWhereInput;
  order_none?: OrderWhereInput;
  AND?: StudentWhereInput[] | StudentWhereInput;
  OR?: StudentWhereInput[] | StudentWhereInput;
  NOT?: StudentWhereInput[] | StudentWhereInput;
}

export interface OrderWhereInput {
  order?: String;
  order_not?: String;
  order_in?: String[] | String;
  order_not_in?: String[] | String;
  order_lt?: String;
  order_lte?: String;
  order_gt?: String;
  order_gte?: String;
  order_contains?: String;
  order_not_contains?: String;
  order_starts_with?: String;
  order_not_starts_with?: String;
  order_ends_with?: String;
  order_not_ends_with?: String;
  stuednt?: StudentWhereInput;
  parents?: ParentWhereInput;
  status?: OrderStatus;
  status_not?: OrderStatus;
  status_in?: OrderStatus[] | OrderStatus;
  status_not_in?: OrderStatus[] | OrderStatus;
  AND?: OrderWhereInput[] | OrderWhereInput;
  OR?: OrderWhereInput[] | OrderWhereInput;
  NOT?: OrderWhereInput[] | OrderWhereInput;
}

export interface ParentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  subjects_every?: SubjectWhereInput;
  subjects_some?: SubjectWhereInput;
  subjects_none?: SubjectWhereInput;
  authstatus?: AuthStatus;
  authstatus_not?: AuthStatus;
  authstatus_in?: AuthStatus[] | AuthStatus;
  authstatus_not_in?: AuthStatus[] | AuthStatus;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  lessonTime?: Int;
  lessonTime_not?: Int;
  lessonTime_in?: Int[] | Int;
  lessonTime_not_in?: Int[] | Int;
  lessonTime_lt?: Int;
  lessonTime_lte?: Int;
  lessonTime_gt?: Int;
  lessonTime_gte?: Int;
  days?: Int;
  days_not?: Int;
  days_in?: Int[] | Int;
  days_not_in?: Int[] | Int;
  days_lt?: Int;
  days_lte?: Int;
  days_gt?: Int;
  days_gte?: Int;
  pay?: Int;
  pay_not?: Int;
  pay_in?: Int[] | Int;
  pay_not_in?: Int[] | Int;
  pay_lt?: Int;
  pay_lte?: Int;
  pay_gt?: Int;
  pay_gte?: Int;
  childGender?: Gender;
  childGender_not?: Gender;
  childGender_in?: Gender[] | Gender;
  childGender_not_in?: Gender[] | Gender;
  invitations_every?: InvitationWhereInput;
  invitations_some?: InvitationWhereInput;
  invitations_none?: InvitationWhereInput;
  order_every?: OrderWhereInput;
  order_some?: OrderWhereInput;
  order_none?: OrderWhereInput;
  teacherReuqire?: String;
  teacherReuqire_not?: String;
  teacherReuqire_in?: String[] | String;
  teacherReuqire_not_in?: String[] | String;
  teacherReuqire_lt?: String;
  teacherReuqire_lte?: String;
  teacherReuqire_gt?: String;
  teacherReuqire_gte?: String;
  teacherReuqire_contains?: String;
  teacherReuqire_not_contains?: String;
  teacherReuqire_starts_with?: String;
  teacherReuqire_not_starts_with?: String;
  teacherReuqire_ends_with?: String;
  teacherReuqire_not_ends_with?: String;
  childStatus?: String;
  childStatus_not?: String;
  childStatus_in?: String[] | String;
  childStatus_not_in?: String[] | String;
  childStatus_lt?: String;
  childStatus_lte?: String;
  childStatus_gt?: String;
  childStatus_gte?: String;
  childStatus_contains?: String;
  childStatus_not_contains?: String;
  childStatus_starts_with?: String;
  childStatus_not_starts_with?: String;
  childStatus_ends_with?: String;
  childStatus_not_ends_with?: String;
  AND?: ParentWhereInput[] | ParentWhereInput;
  OR?: ParentWhereInput[] | ParentWhereInput;
  NOT?: ParentWhereInput[] | ParentWhereInput;
}

export type OrderWhereUniqueInput = AtLeastOne<{
  order: String;
}>;

export type ParentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  phone?: String;
  name?: String;
  email?: String;
}>;

export type StudentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  phone?: String;
  name?: String;
  email?: String;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface AvalibelTimeCreateInput {
  day: Day;
  detail: DetailTime;
}

export interface AvalibelTimeUpdateManyMutationInput {
  day?: Day;
  detail?: DetailTime;
}

export interface InvitationCreateInput {
  stuednt: StudentCreateOneWithoutInvitationsInput;
  parents: ParentCreateOneWithoutInvitationsInput;
  status: InvitationStatus;
}

export interface StudentCreateOneWithoutInvitationsInput {
  create?: StudentCreateWithoutInvitationsInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudentCreateWithoutInvitationsInput {
  phone: String;
  name: String;
  university: University;
  email: String;
  Gender?: Gender;
  authstatus: AuthStatus;
  subjects?: SubjectCreateManyInput;
  avalible?: AvalibelTimeCreateManyInput;
  order?: OrderCreateManyWithoutStuedntInput;
}

export interface SubjectCreateManyInput {
  create?: SubjectCreateInput[] | SubjectCreateInput;
}

export interface SubjectCreateInput {
  name: SubjectName;
  level?: SubjectCreatelevelInput;
}

export interface SubjectCreatelevelInput {
  set?: Level[] | Level;
}

export interface AvalibelTimeCreateManyInput {
  create?: AvalibelTimeCreateInput[] | AvalibelTimeCreateInput;
}

export interface OrderCreateManyWithoutStuedntInput {
  create?: OrderCreateWithoutStuedntInput[] | OrderCreateWithoutStuedntInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
}

export interface OrderCreateWithoutStuedntInput {
  order: String;
  parents: ParentCreateOneWithoutOrderInput;
  status: OrderStatus;
}

export interface ParentCreateOneWithoutOrderInput {
  create?: ParentCreateWithoutOrderInput;
  connect?: ParentWhereUniqueInput;
}

export interface ParentCreateWithoutOrderInput {
  phone: String;
  name: String;
  address: String;
  email: String;
  subjects?: SubjectCreateManyInput;
  authstatus: AuthStatus;
  lessonTime?: Int;
  days?: Int;
  pay?: Int;
  childGender?: Gender;
  invitations?: InvitationCreateManyWithoutParentsInput;
  teacherReuqire?: String;
  childStatus?: String;
}

export interface InvitationCreateManyWithoutParentsInput {
  create?:
    | InvitationCreateWithoutParentsInput[]
    | InvitationCreateWithoutParentsInput;
  connect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
}

export interface InvitationCreateWithoutParentsInput {
  stuednt: StudentCreateOneWithoutInvitationsInput;
  status: InvitationStatus;
}

export interface ParentCreateOneWithoutInvitationsInput {
  create?: ParentCreateWithoutInvitationsInput;
  connect?: ParentWhereUniqueInput;
}

export interface ParentCreateWithoutInvitationsInput {
  phone: String;
  name: String;
  address: String;
  email: String;
  subjects?: SubjectCreateManyInput;
  authstatus: AuthStatus;
  lessonTime?: Int;
  days?: Int;
  pay?: Int;
  childGender?: Gender;
  order?: OrderCreateManyWithoutParentsInput;
  teacherReuqire?: String;
  childStatus?: String;
}

export interface OrderCreateManyWithoutParentsInput {
  create?: OrderCreateWithoutParentsInput[] | OrderCreateWithoutParentsInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
}

export interface OrderCreateWithoutParentsInput {
  order: String;
  stuednt: StudentCreateOneWithoutOrderInput;
  status: OrderStatus;
}

export interface StudentCreateOneWithoutOrderInput {
  create?: StudentCreateWithoutOrderInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudentCreateWithoutOrderInput {
  phone: String;
  name: String;
  university: University;
  email: String;
  Gender?: Gender;
  authstatus: AuthStatus;
  subjects?: SubjectCreateManyInput;
  avalible?: AvalibelTimeCreateManyInput;
  invitations?: InvitationCreateManyWithoutStuedntInput;
}

export interface InvitationCreateManyWithoutStuedntInput {
  create?:
    | InvitationCreateWithoutStuedntInput[]
    | InvitationCreateWithoutStuedntInput;
  connect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
}

export interface InvitationCreateWithoutStuedntInput {
  parents: ParentCreateOneWithoutInvitationsInput;
  status: InvitationStatus;
}

export interface InvitationUpdateInput {
  stuednt?: StudentUpdateOneRequiredWithoutInvitationsInput;
  parents?: ParentUpdateOneRequiredWithoutInvitationsInput;
  status?: InvitationStatus;
}

export interface StudentUpdateOneRequiredWithoutInvitationsInput {
  create?: StudentCreateWithoutInvitationsInput;
  update?: StudentUpdateWithoutInvitationsDataInput;
  upsert?: StudentUpsertWithoutInvitationsInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudentUpdateWithoutInvitationsDataInput {
  phone?: String;
  name?: String;
  university?: University;
  email?: String;
  Gender?: Gender;
  authstatus?: AuthStatus;
  subjects?: SubjectUpdateManyInput;
  avalible?: AvalibelTimeUpdateManyInput;
  order?: OrderUpdateManyWithoutStuedntInput;
}

export interface SubjectUpdateManyInput {
  create?: SubjectCreateInput[] | SubjectCreateInput;
  deleteMany?: SubjectScalarWhereInput[] | SubjectScalarWhereInput;
  updateMany?:
    | SubjectUpdateManyWithWhereNestedInput[]
    | SubjectUpdateManyWithWhereNestedInput;
}

export interface SubjectScalarWhereInput {
  name?: SubjectName;
  name_not?: SubjectName;
  name_in?: SubjectName[] | SubjectName;
  name_not_in?: SubjectName[] | SubjectName;
  AND?: SubjectScalarWhereInput[] | SubjectScalarWhereInput;
  OR?: SubjectScalarWhereInput[] | SubjectScalarWhereInput;
  NOT?: SubjectScalarWhereInput[] | SubjectScalarWhereInput;
}

export interface SubjectUpdateManyWithWhereNestedInput {
  where: SubjectScalarWhereInput;
  data: SubjectUpdateManyDataInput;
}

export interface SubjectUpdateManyDataInput {
  name?: SubjectName;
  level?: SubjectUpdatelevelInput;
}

export interface SubjectUpdatelevelInput {
  set?: Level[] | Level;
}

export interface AvalibelTimeUpdateManyInput {
  create?: AvalibelTimeCreateInput[] | AvalibelTimeCreateInput;
  deleteMany?: AvalibelTimeScalarWhereInput[] | AvalibelTimeScalarWhereInput;
  updateMany?:
    | AvalibelTimeUpdateManyWithWhereNestedInput[]
    | AvalibelTimeUpdateManyWithWhereNestedInput;
}

export interface AvalibelTimeScalarWhereInput {
  day?: Day;
  day_not?: Day;
  day_in?: Day[] | Day;
  day_not_in?: Day[] | Day;
  detail?: DetailTime;
  detail_not?: DetailTime;
  detail_in?: DetailTime[] | DetailTime;
  detail_not_in?: DetailTime[] | DetailTime;
  AND?: AvalibelTimeScalarWhereInput[] | AvalibelTimeScalarWhereInput;
  OR?: AvalibelTimeScalarWhereInput[] | AvalibelTimeScalarWhereInput;
  NOT?: AvalibelTimeScalarWhereInput[] | AvalibelTimeScalarWhereInput;
}

export interface AvalibelTimeUpdateManyWithWhereNestedInput {
  where: AvalibelTimeScalarWhereInput;
  data: AvalibelTimeUpdateManyDataInput;
}

export interface AvalibelTimeUpdateManyDataInput {
  day?: Day;
  detail?: DetailTime;
}

export interface OrderUpdateManyWithoutStuedntInput {
  create?: OrderCreateWithoutStuedntInput[] | OrderCreateWithoutStuedntInput;
  delete?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  disconnect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  update?:
    | OrderUpdateWithWhereUniqueWithoutStuedntInput[]
    | OrderUpdateWithWhereUniqueWithoutStuedntInput;
  upsert?:
    | OrderUpsertWithWhereUniqueWithoutStuedntInput[]
    | OrderUpsertWithWhereUniqueWithoutStuedntInput;
  deleteMany?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  updateMany?:
    | OrderUpdateManyWithWhereNestedInput[]
    | OrderUpdateManyWithWhereNestedInput;
}

export interface OrderUpdateWithWhereUniqueWithoutStuedntInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutStuedntDataInput;
}

export interface OrderUpdateWithoutStuedntDataInput {
  order?: String;
  parents?: ParentUpdateOneRequiredWithoutOrderInput;
  status?: OrderStatus;
}

export interface ParentUpdateOneRequiredWithoutOrderInput {
  create?: ParentCreateWithoutOrderInput;
  update?: ParentUpdateWithoutOrderDataInput;
  upsert?: ParentUpsertWithoutOrderInput;
  connect?: ParentWhereUniqueInput;
}

export interface ParentUpdateWithoutOrderDataInput {
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  subjects?: SubjectUpdateManyInput;
  authstatus?: AuthStatus;
  lessonTime?: Int;
  days?: Int;
  pay?: Int;
  childGender?: Gender;
  invitations?: InvitationUpdateManyWithoutParentsInput;
  teacherReuqire?: String;
  childStatus?: String;
}

export interface InvitationUpdateManyWithoutParentsInput {
  create?:
    | InvitationCreateWithoutParentsInput[]
    | InvitationCreateWithoutParentsInput;
  delete?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  connect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  disconnect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  update?:
    | InvitationUpdateWithWhereUniqueWithoutParentsInput[]
    | InvitationUpdateWithWhereUniqueWithoutParentsInput;
  upsert?:
    | InvitationUpsertWithWhereUniqueWithoutParentsInput[]
    | InvitationUpsertWithWhereUniqueWithoutParentsInput;
  deleteMany?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
  updateMany?:
    | InvitationUpdateManyWithWhereNestedInput[]
    | InvitationUpdateManyWithWhereNestedInput;
}

export interface InvitationUpdateWithWhereUniqueWithoutParentsInput {
  where: InvitationWhereUniqueInput;
  data: InvitationUpdateWithoutParentsDataInput;
}

export interface InvitationUpdateWithoutParentsDataInput {
  stuednt?: StudentUpdateOneRequiredWithoutInvitationsInput;
  status?: InvitationStatus;
}

export interface InvitationUpsertWithWhereUniqueWithoutParentsInput {
  where: InvitationWhereUniqueInput;
  update: InvitationUpdateWithoutParentsDataInput;
  create: InvitationCreateWithoutParentsInput;
}

export interface InvitationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: InvitationStatus;
  status_not?: InvitationStatus;
  status_in?: InvitationStatus[] | InvitationStatus;
  status_not_in?: InvitationStatus[] | InvitationStatus;
  AND?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
  OR?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
  NOT?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
}

export interface InvitationUpdateManyWithWhereNestedInput {
  where: InvitationScalarWhereInput;
  data: InvitationUpdateManyDataInput;
}

export interface InvitationUpdateManyDataInput {
  status?: InvitationStatus;
}

export interface ParentUpsertWithoutOrderInput {
  update: ParentUpdateWithoutOrderDataInput;
  create: ParentCreateWithoutOrderInput;
}

export interface OrderUpsertWithWhereUniqueWithoutStuedntInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutStuedntDataInput;
  create: OrderCreateWithoutStuedntInput;
}

export interface OrderScalarWhereInput {
  order?: String;
  order_not?: String;
  order_in?: String[] | String;
  order_not_in?: String[] | String;
  order_lt?: String;
  order_lte?: String;
  order_gt?: String;
  order_gte?: String;
  order_contains?: String;
  order_not_contains?: String;
  order_starts_with?: String;
  order_not_starts_with?: String;
  order_ends_with?: String;
  order_not_ends_with?: String;
  status?: OrderStatus;
  status_not?: OrderStatus;
  status_in?: OrderStatus[] | OrderStatus;
  status_not_in?: OrderStatus[] | OrderStatus;
  AND?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  OR?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  NOT?: OrderScalarWhereInput[] | OrderScalarWhereInput;
}

export interface OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput;
  data: OrderUpdateManyDataInput;
}

export interface OrderUpdateManyDataInput {
  order?: String;
  status?: OrderStatus;
}

export interface StudentUpsertWithoutInvitationsInput {
  update: StudentUpdateWithoutInvitationsDataInput;
  create: StudentCreateWithoutInvitationsInput;
}

export interface ParentUpdateOneRequiredWithoutInvitationsInput {
  create?: ParentCreateWithoutInvitationsInput;
  update?: ParentUpdateWithoutInvitationsDataInput;
  upsert?: ParentUpsertWithoutInvitationsInput;
  connect?: ParentWhereUniqueInput;
}

export interface ParentUpdateWithoutInvitationsDataInput {
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  subjects?: SubjectUpdateManyInput;
  authstatus?: AuthStatus;
  lessonTime?: Int;
  days?: Int;
  pay?: Int;
  childGender?: Gender;
  order?: OrderUpdateManyWithoutParentsInput;
  teacherReuqire?: String;
  childStatus?: String;
}

export interface OrderUpdateManyWithoutParentsInput {
  create?: OrderCreateWithoutParentsInput[] | OrderCreateWithoutParentsInput;
  delete?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  disconnect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  update?:
    | OrderUpdateWithWhereUniqueWithoutParentsInput[]
    | OrderUpdateWithWhereUniqueWithoutParentsInput;
  upsert?:
    | OrderUpsertWithWhereUniqueWithoutParentsInput[]
    | OrderUpsertWithWhereUniqueWithoutParentsInput;
  deleteMany?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  updateMany?:
    | OrderUpdateManyWithWhereNestedInput[]
    | OrderUpdateManyWithWhereNestedInput;
}

export interface OrderUpdateWithWhereUniqueWithoutParentsInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutParentsDataInput;
}

export interface OrderUpdateWithoutParentsDataInput {
  order?: String;
  stuednt?: StudentUpdateOneRequiredWithoutOrderInput;
  status?: OrderStatus;
}

export interface StudentUpdateOneRequiredWithoutOrderInput {
  create?: StudentCreateWithoutOrderInput;
  update?: StudentUpdateWithoutOrderDataInput;
  upsert?: StudentUpsertWithoutOrderInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudentUpdateWithoutOrderDataInput {
  phone?: String;
  name?: String;
  university?: University;
  email?: String;
  Gender?: Gender;
  authstatus?: AuthStatus;
  subjects?: SubjectUpdateManyInput;
  avalible?: AvalibelTimeUpdateManyInput;
  invitations?: InvitationUpdateManyWithoutStuedntInput;
}

export interface InvitationUpdateManyWithoutStuedntInput {
  create?:
    | InvitationCreateWithoutStuedntInput[]
    | InvitationCreateWithoutStuedntInput;
  delete?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  connect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  disconnect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  update?:
    | InvitationUpdateWithWhereUniqueWithoutStuedntInput[]
    | InvitationUpdateWithWhereUniqueWithoutStuedntInput;
  upsert?:
    | InvitationUpsertWithWhereUniqueWithoutStuedntInput[]
    | InvitationUpsertWithWhereUniqueWithoutStuedntInput;
  deleteMany?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
  updateMany?:
    | InvitationUpdateManyWithWhereNestedInput[]
    | InvitationUpdateManyWithWhereNestedInput;
}

export interface InvitationUpdateWithWhereUniqueWithoutStuedntInput {
  where: InvitationWhereUniqueInput;
  data: InvitationUpdateWithoutStuedntDataInput;
}

export interface InvitationUpdateWithoutStuedntDataInput {
  parents?: ParentUpdateOneRequiredWithoutInvitationsInput;
  status?: InvitationStatus;
}

export interface InvitationUpsertWithWhereUniqueWithoutStuedntInput {
  where: InvitationWhereUniqueInput;
  update: InvitationUpdateWithoutStuedntDataInput;
  create: InvitationCreateWithoutStuedntInput;
}

export interface StudentUpsertWithoutOrderInput {
  update: StudentUpdateWithoutOrderDataInput;
  create: StudentCreateWithoutOrderInput;
}

export interface OrderUpsertWithWhereUniqueWithoutParentsInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutParentsDataInput;
  create: OrderCreateWithoutParentsInput;
}

export interface ParentUpsertWithoutInvitationsInput {
  update: ParentUpdateWithoutInvitationsDataInput;
  create: ParentCreateWithoutInvitationsInput;
}

export interface InvitationUpdateManyMutationInput {
  status?: InvitationStatus;
}

export interface OrderCreateInput {
  order: String;
  stuednt: StudentCreateOneWithoutOrderInput;
  parents: ParentCreateOneWithoutOrderInput;
  status: OrderStatus;
}

export interface OrderUpdateInput {
  order?: String;
  stuednt?: StudentUpdateOneRequiredWithoutOrderInput;
  parents?: ParentUpdateOneRequiredWithoutOrderInput;
  status?: OrderStatus;
}

export interface OrderUpdateManyMutationInput {
  order?: String;
  status?: OrderStatus;
}

export interface ParentCreateInput {
  phone: String;
  name: String;
  address: String;
  email: String;
  subjects?: SubjectCreateManyInput;
  authstatus: AuthStatus;
  lessonTime?: Int;
  days?: Int;
  pay?: Int;
  childGender?: Gender;
  invitations?: InvitationCreateManyWithoutParentsInput;
  order?: OrderCreateManyWithoutParentsInput;
  teacherReuqire?: String;
  childStatus?: String;
}

export interface ParentUpdateInput {
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  subjects?: SubjectUpdateManyInput;
  authstatus?: AuthStatus;
  lessonTime?: Int;
  days?: Int;
  pay?: Int;
  childGender?: Gender;
  invitations?: InvitationUpdateManyWithoutParentsInput;
  order?: OrderUpdateManyWithoutParentsInput;
  teacherReuqire?: String;
  childStatus?: String;
}

export interface ParentUpdateManyMutationInput {
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  authstatus?: AuthStatus;
  lessonTime?: Int;
  days?: Int;
  pay?: Int;
  childGender?: Gender;
  teacherReuqire?: String;
  childStatus?: String;
}

export interface StudentCreateInput {
  phone: String;
  name: String;
  university: University;
  email: String;
  Gender?: Gender;
  authstatus: AuthStatus;
  subjects?: SubjectCreateManyInput;
  avalible?: AvalibelTimeCreateManyInput;
  invitations?: InvitationCreateManyWithoutStuedntInput;
  order?: OrderCreateManyWithoutStuedntInput;
}

export interface StudentUpdateInput {
  phone?: String;
  name?: String;
  university?: University;
  email?: String;
  Gender?: Gender;
  authstatus?: AuthStatus;
  subjects?: SubjectUpdateManyInput;
  avalible?: AvalibelTimeUpdateManyInput;
  invitations?: InvitationUpdateManyWithoutStuedntInput;
  order?: OrderUpdateManyWithoutStuedntInput;
}

export interface StudentUpdateManyMutationInput {
  phone?: String;
  name?: String;
  university?: University;
  email?: String;
  Gender?: Gender;
  authstatus?: AuthStatus;
}

export interface SubjectUpdateManyMutationInput {
  name?: SubjectName;
  level?: SubjectUpdatelevelInput;
}

export interface UserCreateInput {
  name: String;
}

export interface UserUpdateInput {
  name?: String;
}

export interface UserUpdateManyMutationInput {
  name?: String;
}

export interface AvalibelTimeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AvalibelTimeWhereInput;
  AND?:
    | AvalibelTimeSubscriptionWhereInput[]
    | AvalibelTimeSubscriptionWhereInput;
  OR?:
    | AvalibelTimeSubscriptionWhereInput[]
    | AvalibelTimeSubscriptionWhereInput;
  NOT?:
    | AvalibelTimeSubscriptionWhereInput[]
    | AvalibelTimeSubscriptionWhereInput;
}

export interface InvitationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InvitationWhereInput;
  AND?: InvitationSubscriptionWhereInput[] | InvitationSubscriptionWhereInput;
  OR?: InvitationSubscriptionWhereInput[] | InvitationSubscriptionWhereInput;
  NOT?: InvitationSubscriptionWhereInput[] | InvitationSubscriptionWhereInput;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrderWhereInput;
  AND?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
  OR?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
  NOT?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
}

export interface ParentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ParentWhereInput;
  AND?: ParentSubscriptionWhereInput[] | ParentSubscriptionWhereInput;
  OR?: ParentSubscriptionWhereInput[] | ParentSubscriptionWhereInput;
  NOT?: ParentSubscriptionWhereInput[] | ParentSubscriptionWhereInput;
}

export interface StudentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StudentWhereInput;
  AND?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
  OR?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
  NOT?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
}

export interface SubjectSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SubjectWhereInput;
  AND?: SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput;
  OR?: SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput;
  NOT?: SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AvalibelTime {
  day: Day;
  detail: DetailTime;
}

export interface AvalibelTimePromise
  extends Promise<AvalibelTime>,
    Fragmentable {
  day: () => Promise<Day>;
  detail: () => Promise<DetailTime>;
}

export interface AvalibelTimeSubscription
  extends Promise<AsyncIterator<AvalibelTime>>,
    Fragmentable {
  day: () => Promise<AsyncIterator<Day>>;
  detail: () => Promise<AsyncIterator<DetailTime>>;
}

export interface AvalibelTimeConnection {
  pageInfo: PageInfo;
  edges: AvalibelTimeEdge[];
}

export interface AvalibelTimeConnectionPromise
  extends Promise<AvalibelTimeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AvalibelTimeEdge>>() => T;
  aggregate: <T = AggregateAvalibelTimePromise>() => T;
}

export interface AvalibelTimeConnectionSubscription
  extends Promise<AsyncIterator<AvalibelTimeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AvalibelTimeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAvalibelTimeSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AvalibelTimeEdge {
  node: AvalibelTime;
  cursor: String;
}

export interface AvalibelTimeEdgePromise
  extends Promise<AvalibelTimeEdge>,
    Fragmentable {
  node: <T = AvalibelTimePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AvalibelTimeEdgeSubscription
  extends Promise<AsyncIterator<AvalibelTimeEdge>>,
    Fragmentable {
  node: <T = AvalibelTimeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAvalibelTime {
  count: Int;
}

export interface AggregateAvalibelTimePromise
  extends Promise<AggregateAvalibelTime>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAvalibelTimeSubscription
  extends Promise<AsyncIterator<AggregateAvalibelTime>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Invitation {
  id: ID_Output;
  status: InvitationStatus;
}

export interface InvitationPromise extends Promise<Invitation>, Fragmentable {
  id: () => Promise<ID_Output>;
  stuednt: <T = StudentPromise>() => T;
  parents: <T = ParentPromise>() => T;
  status: () => Promise<InvitationStatus>;
}

export interface InvitationSubscription
  extends Promise<AsyncIterator<Invitation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  stuednt: <T = StudentSubscription>() => T;
  parents: <T = ParentSubscription>() => T;
  status: () => Promise<AsyncIterator<InvitationStatus>>;
}

export interface Student {
  id: ID_Output;
  phone: String;
  name: String;
  university: University;
  email: String;
  Gender?: Gender;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  authstatus: AuthStatus;
}

export interface StudentPromise extends Promise<Student>, Fragmentable {
  id: () => Promise<ID_Output>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  university: () => Promise<University>;
  email: () => Promise<String>;
  Gender: () => Promise<Gender>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  authstatus: () => Promise<AuthStatus>;
  subjects: <T = FragmentableArray<Subject>>(args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  avalible: <T = FragmentableArray<AvalibelTime>>(args?: {
    where?: AvalibelTimeWhereInput;
    orderBy?: AvalibelTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invitations: <T = FragmentableArray<Invitation>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface StudentSubscription
  extends Promise<AsyncIterator<Student>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phone: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  university: () => Promise<AsyncIterator<University>>;
  email: () => Promise<AsyncIterator<String>>;
  Gender: () => Promise<AsyncIterator<Gender>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  authstatus: () => Promise<AsyncIterator<AuthStatus>>;
  subjects: <T = Promise<AsyncIterator<SubjectSubscription>>>(args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  avalible: <T = Promise<AsyncIterator<AvalibelTimeSubscription>>>(args?: {
    where?: AvalibelTimeWhereInput;
    orderBy?: AvalibelTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invitations: <T = Promise<AsyncIterator<InvitationSubscription>>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Subject {
  name: SubjectName;
  level: Level[];
}

export interface SubjectPromise extends Promise<Subject>, Fragmentable {
  name: () => Promise<SubjectName>;
  level: () => Promise<Level[]>;
}

export interface SubjectSubscription
  extends Promise<AsyncIterator<Subject>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<SubjectName>>;
  level: () => Promise<AsyncIterator<Level[]>>;
}

export interface Order {
  order: String;
  status: OrderStatus;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  order: () => Promise<String>;
  stuednt: <T = StudentPromise>() => T;
  parents: <T = ParentPromise>() => T;
  status: () => Promise<OrderStatus>;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  order: () => Promise<AsyncIterator<String>>;
  stuednt: <T = StudentSubscription>() => T;
  parents: <T = ParentSubscription>() => T;
  status: () => Promise<AsyncIterator<OrderStatus>>;
}

export interface Parent {
  id: ID_Output;
  phone: String;
  name: String;
  address: String;
  email: String;
  authstatus: AuthStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  lessonTime?: Int;
  days?: Int;
  pay?: Int;
  childGender: Gender;
  teacherReuqire?: String;
  childStatus?: String;
}

export interface ParentPromise extends Promise<Parent>, Fragmentable {
  id: () => Promise<ID_Output>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  email: () => Promise<String>;
  subjects: <T = FragmentableArray<Subject>>(args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  authstatus: () => Promise<AuthStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  lessonTime: () => Promise<Int>;
  days: () => Promise<Int>;
  pay: () => Promise<Int>;
  childGender: () => Promise<Gender>;
  invitations: <T = FragmentableArray<Invitation>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  teacherReuqire: () => Promise<String>;
  childStatus: () => Promise<String>;
}

export interface ParentSubscription
  extends Promise<AsyncIterator<Parent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phone: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  subjects: <T = Promise<AsyncIterator<SubjectSubscription>>>(args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  authstatus: () => Promise<AsyncIterator<AuthStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  lessonTime: () => Promise<AsyncIterator<Int>>;
  days: () => Promise<AsyncIterator<Int>>;
  pay: () => Promise<AsyncIterator<Int>>;
  childGender: () => Promise<AsyncIterator<Gender>>;
  invitations: <T = Promise<AsyncIterator<InvitationSubscription>>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  teacherReuqire: () => Promise<AsyncIterator<String>>;
  childStatus: () => Promise<AsyncIterator<String>>;
}

export interface InvitationConnection {
  pageInfo: PageInfo;
  edges: InvitationEdge[];
}

export interface InvitationConnectionPromise
  extends Promise<InvitationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InvitationEdge>>() => T;
  aggregate: <T = AggregateInvitationPromise>() => T;
}

export interface InvitationConnectionSubscription
  extends Promise<AsyncIterator<InvitationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InvitationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInvitationSubscription>() => T;
}

export interface InvitationEdge {
  node: Invitation;
  cursor: String;
}

export interface InvitationEdgePromise
  extends Promise<InvitationEdge>,
    Fragmentable {
  node: <T = InvitationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InvitationEdgeSubscription
  extends Promise<AsyncIterator<InvitationEdge>>,
    Fragmentable {
  node: <T = InvitationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInvitation {
  count: Int;
}

export interface AggregateInvitationPromise
  extends Promise<AggregateInvitation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInvitationSubscription
  extends Promise<AsyncIterator<AggregateInvitation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ParentConnection {
  pageInfo: PageInfo;
  edges: ParentEdge[];
}

export interface ParentConnectionPromise
  extends Promise<ParentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ParentEdge>>() => T;
  aggregate: <T = AggregateParentPromise>() => T;
}

export interface ParentConnectionSubscription
  extends Promise<AsyncIterator<ParentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ParentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateParentSubscription>() => T;
}

export interface ParentEdge {
  node: Parent;
  cursor: String;
}

export interface ParentEdgePromise extends Promise<ParentEdge>, Fragmentable {
  node: <T = ParentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ParentEdgeSubscription
  extends Promise<AsyncIterator<ParentEdge>>,
    Fragmentable {
  node: <T = ParentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateParent {
  count: Int;
}

export interface AggregateParentPromise
  extends Promise<AggregateParent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateParentSubscription
  extends Promise<AsyncIterator<AggregateParent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudentConnection {
  pageInfo: PageInfo;
  edges: StudentEdge[];
}

export interface StudentConnectionPromise
  extends Promise<StudentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudentEdge>>() => T;
  aggregate: <T = AggregateStudentPromise>() => T;
}

export interface StudentConnectionSubscription
  extends Promise<AsyncIterator<StudentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudentSubscription>() => T;
}

export interface StudentEdge {
  node: Student;
  cursor: String;
}

export interface StudentEdgePromise extends Promise<StudentEdge>, Fragmentable {
  node: <T = StudentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudentEdgeSubscription
  extends Promise<AsyncIterator<StudentEdge>>,
    Fragmentable {
  node: <T = StudentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudent {
  count: Int;
}

export interface AggregateStudentPromise
  extends Promise<AggregateStudent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudentSubscription
  extends Promise<AsyncIterator<AggregateStudent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubjectConnection {
  pageInfo: PageInfo;
  edges: SubjectEdge[];
}

export interface SubjectConnectionPromise
  extends Promise<SubjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubjectEdge>>() => T;
  aggregate: <T = AggregateSubjectPromise>() => T;
}

export interface SubjectConnectionSubscription
  extends Promise<AsyncIterator<SubjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubjectSubscription>() => T;
}

export interface SubjectEdge {
  node: Subject;
  cursor: String;
}

export interface SubjectEdgePromise extends Promise<SubjectEdge>, Fragmentable {
  node: <T = SubjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubjectEdgeSubscription
  extends Promise<AsyncIterator<SubjectEdge>>,
    Fragmentable {
  node: <T = SubjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubject {
  count: Int;
}

export interface AggregateSubjectPromise
  extends Promise<AggregateSubject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubjectSubscription
  extends Promise<AsyncIterator<AggregateSubject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  name: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AvalibelTimeSubscriptionPayload {
  mutation: MutationType;
  node: AvalibelTime;
  updatedFields: String[];
  previousValues: AvalibelTimePreviousValues;
}

export interface AvalibelTimeSubscriptionPayloadPromise
  extends Promise<AvalibelTimeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AvalibelTimePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AvalibelTimePreviousValuesPromise>() => T;
}

export interface AvalibelTimeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AvalibelTimeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AvalibelTimeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AvalibelTimePreviousValuesSubscription>() => T;
}

export interface AvalibelTimePreviousValues {
  day: Day;
  detail: DetailTime;
}

export interface AvalibelTimePreviousValuesPromise
  extends Promise<AvalibelTimePreviousValues>,
    Fragmentable {
  day: () => Promise<Day>;
  detail: () => Promise<DetailTime>;
}

export interface AvalibelTimePreviousValuesSubscription
  extends Promise<AsyncIterator<AvalibelTimePreviousValues>>,
    Fragmentable {
  day: () => Promise<AsyncIterator<Day>>;
  detail: () => Promise<AsyncIterator<DetailTime>>;
}

export interface InvitationSubscriptionPayload {
  mutation: MutationType;
  node: Invitation;
  updatedFields: String[];
  previousValues: InvitationPreviousValues;
}

export interface InvitationSubscriptionPayloadPromise
  extends Promise<InvitationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InvitationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InvitationPreviousValuesPromise>() => T;
}

export interface InvitationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InvitationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InvitationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InvitationPreviousValuesSubscription>() => T;
}

export interface InvitationPreviousValues {
  id: ID_Output;
  status: InvitationStatus;
}

export interface InvitationPreviousValuesPromise
  extends Promise<InvitationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<InvitationStatus>;
}

export interface InvitationPreviousValuesSubscription
  extends Promise<AsyncIterator<InvitationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<InvitationStatus>>;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface OrderPreviousValues {
  order: String;
  status: OrderStatus;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  order: () => Promise<String>;
  status: () => Promise<OrderStatus>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  order: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<OrderStatus>>;
}

export interface ParentSubscriptionPayload {
  mutation: MutationType;
  node: Parent;
  updatedFields: String[];
  previousValues: ParentPreviousValues;
}

export interface ParentSubscriptionPayloadPromise
  extends Promise<ParentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ParentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ParentPreviousValuesPromise>() => T;
}

export interface ParentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ParentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ParentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ParentPreviousValuesSubscription>() => T;
}

export interface ParentPreviousValues {
  id: ID_Output;
  phone: String;
  name: String;
  address: String;
  email: String;
  authstatus: AuthStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  lessonTime?: Int;
  days?: Int;
  pay?: Int;
  childGender: Gender;
  teacherReuqire?: String;
  childStatus?: String;
}

export interface ParentPreviousValuesPromise
  extends Promise<ParentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  email: () => Promise<String>;
  authstatus: () => Promise<AuthStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  lessonTime: () => Promise<Int>;
  days: () => Promise<Int>;
  pay: () => Promise<Int>;
  childGender: () => Promise<Gender>;
  teacherReuqire: () => Promise<String>;
  childStatus: () => Promise<String>;
}

export interface ParentPreviousValuesSubscription
  extends Promise<AsyncIterator<ParentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phone: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  authstatus: () => Promise<AsyncIterator<AuthStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  lessonTime: () => Promise<AsyncIterator<Int>>;
  days: () => Promise<AsyncIterator<Int>>;
  pay: () => Promise<AsyncIterator<Int>>;
  childGender: () => Promise<AsyncIterator<Gender>>;
  teacherReuqire: () => Promise<AsyncIterator<String>>;
  childStatus: () => Promise<AsyncIterator<String>>;
}

export interface StudentSubscriptionPayload {
  mutation: MutationType;
  node: Student;
  updatedFields: String[];
  previousValues: StudentPreviousValues;
}

export interface StudentSubscriptionPayloadPromise
  extends Promise<StudentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudentPreviousValuesPromise>() => T;
}

export interface StudentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudentPreviousValuesSubscription>() => T;
}

export interface StudentPreviousValues {
  id: ID_Output;
  phone: String;
  name: String;
  university: University;
  email: String;
  Gender?: Gender;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  authstatus: AuthStatus;
}

export interface StudentPreviousValuesPromise
  extends Promise<StudentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  university: () => Promise<University>;
  email: () => Promise<String>;
  Gender: () => Promise<Gender>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  authstatus: () => Promise<AuthStatus>;
}

export interface StudentPreviousValuesSubscription
  extends Promise<AsyncIterator<StudentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phone: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  university: () => Promise<AsyncIterator<University>>;
  email: () => Promise<AsyncIterator<String>>;
  Gender: () => Promise<AsyncIterator<Gender>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  authstatus: () => Promise<AsyncIterator<AuthStatus>>;
}

export interface SubjectSubscriptionPayload {
  mutation: MutationType;
  node: Subject;
  updatedFields: String[];
  previousValues: SubjectPreviousValues;
}

export interface SubjectSubscriptionPayloadPromise
  extends Promise<SubjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubjectPreviousValuesPromise>() => T;
}

export interface SubjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubjectPreviousValuesSubscription>() => T;
}

export interface SubjectPreviousValues {
  name: SubjectName;
  level: Level[];
}

export interface SubjectPreviousValuesPromise
  extends Promise<SubjectPreviousValues>,
    Fragmentable {
  name: () => Promise<SubjectName>;
  level: () => Promise<Level[]>;
}

export interface SubjectPreviousValuesSubscription
  extends Promise<AsyncIterator<SubjectPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<SubjectName>>;
  level: () => Promise<AsyncIterator<Level[]>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "AuthStatus",
    embedded: false
  },
  {
    name: "AvalibelTime",
    embedded: false
  },
  {
    name: "Day",
    embedded: false
  },
  {
    name: "DetailTime",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "Invitation",
    embedded: false
  },
  {
    name: "InvitationStatus",
    embedded: false
  },
  {
    name: "Level",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "OrderStatus",
    embedded: false
  },
  {
    name: "Parent",
    embedded: false
  },
  {
    name: "Student",
    embedded: false
  },
  {
    name: "Subject",
    embedded: false
  },
  {
    name: "SubjectName",
    embedded: false
  },
  {
    name: "University",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
