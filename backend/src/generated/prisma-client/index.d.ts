// Code generated by Prisma (prisma@1.24.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  admin: (where?: AdminWhereInput) => Promise<boolean>;
  avalibelTime: (where?: AvalibelTimeWhereInput) => Promise<boolean>;
  basicTermInfo: (where?: BasicTermInfoWhereInput) => Promise<boolean>;
  invitation: (where?: InvitationWhereInput) => Promise<boolean>;
  longTerm: (where?: LongTermWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  parent: (where?: ParentWhereInput) => Promise<boolean>;
  parentAuthInfo: (where?: ParentAuthInfoWhereInput) => Promise<boolean>;
  shortTerm: (where?: ShortTermWhereInput) => Promise<boolean>;
  student: (where?: StudentWhereInput) => Promise<boolean>;
  studentAuthInfo: (where?: StudentAuthInfoWhereInput) => Promise<boolean>;
  studentDetail: (where?: StudentDetailWhereInput) => Promise<boolean>;
  subject: (where?: SubjectWhereInput) => Promise<boolean>;
  tryOrder: (where?: TryOrderWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  emerContact: (where?: emerContactWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  admin: (where: AdminWhereUniqueInput) => AdminPromise;
  admins: (args?: {
    where?: AdminWhereInput;
    orderBy?: AdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Admin>;
  adminsConnection: (args?: {
    where?: AdminWhereInput;
    orderBy?: AdminOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AdminConnectionPromise;
  avalibelTimes: (args?: {
    where?: AvalibelTimeWhereInput;
    orderBy?: AvalibelTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AvalibelTime>;
  avalibelTimesConnection: (args?: {
    where?: AvalibelTimeWhereInput;
    orderBy?: AvalibelTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AvalibelTimeConnectionPromise;
  basicTermInfo: (where: BasicTermInfoWhereUniqueInput) => BasicTermInfoPromise;
  basicTermInfoes: (args?: {
    where?: BasicTermInfoWhereInput;
    orderBy?: BasicTermInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BasicTermInfo>;
  basicTermInfoesConnection: (args?: {
    where?: BasicTermInfoWhereInput;
    orderBy?: BasicTermInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BasicTermInfoConnectionPromise;
  invitation: (where: InvitationWhereUniqueInput) => InvitationPromise;
  invitations: (args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Invitation>;
  invitationsConnection: (args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InvitationConnectionPromise;
  longTerm: (where: LongTermWhereUniqueInput) => LongTermPromise;
  longTerms: (args?: {
    where?: LongTermWhereInput;
    orderBy?: LongTermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LongTerm>;
  longTermsConnection: (args?: {
    where?: LongTermWhereInput;
    orderBy?: LongTermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LongTermConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderPromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  parent: (where: ParentWhereUniqueInput) => ParentPromise;
  parents: (args?: {
    where?: ParentWhereInput;
    orderBy?: ParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Parent>;
  parentsConnection: (args?: {
    where?: ParentWhereInput;
    orderBy?: ParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ParentConnectionPromise;
  parentAuthInfo: (
    where: ParentAuthInfoWhereUniqueInput
  ) => ParentAuthInfoPromise;
  parentAuthInfoes: (args?: {
    where?: ParentAuthInfoWhereInput;
    orderBy?: ParentAuthInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ParentAuthInfo>;
  parentAuthInfoesConnection: (args?: {
    where?: ParentAuthInfoWhereInput;
    orderBy?: ParentAuthInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ParentAuthInfoConnectionPromise;
  shortTerm: (where: ShortTermWhereUniqueInput) => ShortTermPromise;
  shortTerms: (args?: {
    where?: ShortTermWhereInput;
    orderBy?: ShortTermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ShortTerm>;
  shortTermsConnection: (args?: {
    where?: ShortTermWhereInput;
    orderBy?: ShortTermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ShortTermConnectionPromise;
  student: (where: StudentWhereUniqueInput) => StudentPromise;
  students: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Student>;
  studentsConnection: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudentConnectionPromise;
  studentAuthInfo: (
    where: StudentAuthInfoWhereUniqueInput
  ) => StudentAuthInfoPromise;
  studentAuthInfoes: (args?: {
    where?: StudentAuthInfoWhereInput;
    orderBy?: StudentAuthInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StudentAuthInfo>;
  studentAuthInfoesConnection: (args?: {
    where?: StudentAuthInfoWhereInput;
    orderBy?: StudentAuthInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudentAuthInfoConnectionPromise;
  studentDetails: (args?: {
    where?: StudentDetailWhereInput;
    orderBy?: StudentDetailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StudentDetail>;
  studentDetailsConnection: (args?: {
    where?: StudentDetailWhereInput;
    orderBy?: StudentDetailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudentDetailConnectionPromise;
  subjects: (args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Subject>;
  subjectsConnection: (args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubjectConnectionPromise;
  tryOrder: (where: TryOrderWhereUniqueInput) => TryOrderPromise;
  tryOrders: (args?: {
    where?: TryOrderWhereInput;
    orderBy?: TryOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TryOrder>;
  tryOrdersConnection: (args?: {
    where?: TryOrderWhereInput;
    orderBy?: TryOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TryOrderConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  emerContacts: (args?: {
    where?: emerContactWhereInput;
    orderBy?: emerContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<emerContact>;
  emerContactsConnection: (args?: {
    where?: emerContactWhereInput;
    orderBy?: emerContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => emerContactConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAdmin: (data: AdminCreateInput) => AdminPromise;
  updateAdmin: (args: {
    data: AdminUpdateInput;
    where: AdminWhereUniqueInput;
  }) => AdminPromise;
  updateManyAdmins: (args: {
    data: AdminUpdateManyMutationInput;
    where?: AdminWhereInput;
  }) => BatchPayloadPromise;
  upsertAdmin: (args: {
    where: AdminWhereUniqueInput;
    create: AdminCreateInput;
    update: AdminUpdateInput;
  }) => AdminPromise;
  deleteAdmin: (where: AdminWhereUniqueInput) => AdminPromise;
  deleteManyAdmins: (where?: AdminWhereInput) => BatchPayloadPromise;
  createAvalibelTime: (data: AvalibelTimeCreateInput) => AvalibelTimePromise;
  updateManyAvalibelTimes: (args: {
    data: AvalibelTimeUpdateManyMutationInput;
    where?: AvalibelTimeWhereInput;
  }) => BatchPayloadPromise;
  deleteManyAvalibelTimes: (
    where?: AvalibelTimeWhereInput
  ) => BatchPayloadPromise;
  createBasicTermInfo: (data: BasicTermInfoCreateInput) => BasicTermInfoPromise;
  updateBasicTermInfo: (args: {
    data: BasicTermInfoUpdateInput;
    where: BasicTermInfoWhereUniqueInput;
  }) => BasicTermInfoPromise;
  updateManyBasicTermInfoes: (args: {
    data: BasicTermInfoUpdateManyMutationInput;
    where?: BasicTermInfoWhereInput;
  }) => BatchPayloadPromise;
  upsertBasicTermInfo: (args: {
    where: BasicTermInfoWhereUniqueInput;
    create: BasicTermInfoCreateInput;
    update: BasicTermInfoUpdateInput;
  }) => BasicTermInfoPromise;
  deleteBasicTermInfo: (
    where: BasicTermInfoWhereUniqueInput
  ) => BasicTermInfoPromise;
  deleteManyBasicTermInfoes: (
    where?: BasicTermInfoWhereInput
  ) => BatchPayloadPromise;
  createInvitation: (data: InvitationCreateInput) => InvitationPromise;
  updateInvitation: (args: {
    data: InvitationUpdateInput;
    where: InvitationWhereUniqueInput;
  }) => InvitationPromise;
  updateManyInvitations: (args: {
    data: InvitationUpdateManyMutationInput;
    where?: InvitationWhereInput;
  }) => BatchPayloadPromise;
  upsertInvitation: (args: {
    where: InvitationWhereUniqueInput;
    create: InvitationCreateInput;
    update: InvitationUpdateInput;
  }) => InvitationPromise;
  deleteInvitation: (where: InvitationWhereUniqueInput) => InvitationPromise;
  deleteManyInvitations: (where?: InvitationWhereInput) => BatchPayloadPromise;
  createLongTerm: (data: LongTermCreateInput) => LongTermPromise;
  updateLongTerm: (args: {
    data: LongTermUpdateInput;
    where: LongTermWhereUniqueInput;
  }) => LongTermPromise;
  updateManyLongTerms: (args: {
    data: LongTermUpdateManyMutationInput;
    where?: LongTermWhereInput;
  }) => BatchPayloadPromise;
  upsertLongTerm: (args: {
    where: LongTermWhereUniqueInput;
    create: LongTermCreateInput;
    update: LongTermUpdateInput;
  }) => LongTermPromise;
  deleteLongTerm: (where: LongTermWhereUniqueInput) => LongTermPromise;
  deleteManyLongTerms: (where?: LongTermWhereInput) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (args: {
    data: OrderUpdateInput;
    where: OrderWhereUniqueInput;
  }) => OrderPromise;
  updateManyOrders: (args: {
    data: OrderUpdateManyMutationInput;
    where?: OrderWhereInput;
  }) => BatchPayloadPromise;
  upsertOrder: (args: {
    where: OrderWhereUniqueInput;
    create: OrderCreateInput;
    update: OrderUpdateInput;
  }) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createParent: (data: ParentCreateInput) => ParentPromise;
  updateParent: (args: {
    data: ParentUpdateInput;
    where: ParentWhereUniqueInput;
  }) => ParentPromise;
  updateManyParents: (args: {
    data: ParentUpdateManyMutationInput;
    where?: ParentWhereInput;
  }) => BatchPayloadPromise;
  upsertParent: (args: {
    where: ParentWhereUniqueInput;
    create: ParentCreateInput;
    update: ParentUpdateInput;
  }) => ParentPromise;
  deleteParent: (where: ParentWhereUniqueInput) => ParentPromise;
  deleteManyParents: (where?: ParentWhereInput) => BatchPayloadPromise;
  createParentAuthInfo: (
    data: ParentAuthInfoCreateInput
  ) => ParentAuthInfoPromise;
  updateParentAuthInfo: (args: {
    data: ParentAuthInfoUpdateInput;
    where: ParentAuthInfoWhereUniqueInput;
  }) => ParentAuthInfoPromise;
  updateManyParentAuthInfoes: (args: {
    data: ParentAuthInfoUpdateManyMutationInput;
    where?: ParentAuthInfoWhereInput;
  }) => BatchPayloadPromise;
  upsertParentAuthInfo: (args: {
    where: ParentAuthInfoWhereUniqueInput;
    create: ParentAuthInfoCreateInput;
    update: ParentAuthInfoUpdateInput;
  }) => ParentAuthInfoPromise;
  deleteParentAuthInfo: (
    where: ParentAuthInfoWhereUniqueInput
  ) => ParentAuthInfoPromise;
  deleteManyParentAuthInfoes: (
    where?: ParentAuthInfoWhereInput
  ) => BatchPayloadPromise;
  createShortTerm: (data: ShortTermCreateInput) => ShortTermPromise;
  updateShortTerm: (args: {
    data: ShortTermUpdateInput;
    where: ShortTermWhereUniqueInput;
  }) => ShortTermPromise;
  updateManyShortTerms: (args: {
    data: ShortTermUpdateManyMutationInput;
    where?: ShortTermWhereInput;
  }) => BatchPayloadPromise;
  upsertShortTerm: (args: {
    where: ShortTermWhereUniqueInput;
    create: ShortTermCreateInput;
    update: ShortTermUpdateInput;
  }) => ShortTermPromise;
  deleteShortTerm: (where: ShortTermWhereUniqueInput) => ShortTermPromise;
  deleteManyShortTerms: (where?: ShortTermWhereInput) => BatchPayloadPromise;
  createStudent: (data: StudentCreateInput) => StudentPromise;
  updateStudent: (args: {
    data: StudentUpdateInput;
    where: StudentWhereUniqueInput;
  }) => StudentPromise;
  updateManyStudents: (args: {
    data: StudentUpdateManyMutationInput;
    where?: StudentWhereInput;
  }) => BatchPayloadPromise;
  upsertStudent: (args: {
    where: StudentWhereUniqueInput;
    create: StudentCreateInput;
    update: StudentUpdateInput;
  }) => StudentPromise;
  deleteStudent: (where: StudentWhereUniqueInput) => StudentPromise;
  deleteManyStudents: (where?: StudentWhereInput) => BatchPayloadPromise;
  createStudentAuthInfo: (
    data: StudentAuthInfoCreateInput
  ) => StudentAuthInfoPromise;
  updateStudentAuthInfo: (args: {
    data: StudentAuthInfoUpdateInput;
    where: StudentAuthInfoWhereUniqueInput;
  }) => StudentAuthInfoPromise;
  updateManyStudentAuthInfoes: (args: {
    data: StudentAuthInfoUpdateManyMutationInput;
    where?: StudentAuthInfoWhereInput;
  }) => BatchPayloadPromise;
  upsertStudentAuthInfo: (args: {
    where: StudentAuthInfoWhereUniqueInput;
    create: StudentAuthInfoCreateInput;
    update: StudentAuthInfoUpdateInput;
  }) => StudentAuthInfoPromise;
  deleteStudentAuthInfo: (
    where: StudentAuthInfoWhereUniqueInput
  ) => StudentAuthInfoPromise;
  deleteManyStudentAuthInfoes: (
    where?: StudentAuthInfoWhereInput
  ) => BatchPayloadPromise;
  createStudentDetail: (data: StudentDetailCreateInput) => StudentDetailPromise;
  updateManyStudentDetails: (args: {
    data: StudentDetailUpdateManyMutationInput;
    where?: StudentDetailWhereInput;
  }) => BatchPayloadPromise;
  deleteManyStudentDetails: (
    where?: StudentDetailWhereInput
  ) => BatchPayloadPromise;
  createSubject: (data: SubjectCreateInput) => SubjectPromise;
  updateManySubjects: (args: {
    data: SubjectUpdateManyMutationInput;
    where?: SubjectWhereInput;
  }) => BatchPayloadPromise;
  deleteManySubjects: (where?: SubjectWhereInput) => BatchPayloadPromise;
  createTryOrder: (data: TryOrderCreateInput) => TryOrderPromise;
  updateTryOrder: (args: {
    data: TryOrderUpdateInput;
    where: TryOrderWhereUniqueInput;
  }) => TryOrderPromise;
  updateManyTryOrders: (args: {
    data: TryOrderUpdateManyMutationInput;
    where?: TryOrderWhereInput;
  }) => BatchPayloadPromise;
  upsertTryOrder: (args: {
    where: TryOrderWhereUniqueInput;
    create: TryOrderCreateInput;
    update: TryOrderUpdateInput;
  }) => TryOrderPromise;
  deleteTryOrder: (where: TryOrderWhereUniqueInput) => TryOrderPromise;
  deleteManyTryOrders: (where?: TryOrderWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createemerContact: (data: emerContactCreateInput) => emerContactPromise;
  updateManyemerContacts: (args: {
    data: emerContactUpdateManyMutationInput;
    where?: emerContactWhereInput;
  }) => BatchPayloadPromise;
  deleteManyemerContacts: (
    where?: emerContactWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  admin: (
    where?: AdminSubscriptionWhereInput
  ) => AdminSubscriptionPayloadSubscription;
  avalibelTime: (
    where?: AvalibelTimeSubscriptionWhereInput
  ) => AvalibelTimeSubscriptionPayloadSubscription;
  basicTermInfo: (
    where?: BasicTermInfoSubscriptionWhereInput
  ) => BasicTermInfoSubscriptionPayloadSubscription;
  invitation: (
    where?: InvitationSubscriptionWhereInput
  ) => InvitationSubscriptionPayloadSubscription;
  longTerm: (
    where?: LongTermSubscriptionWhereInput
  ) => LongTermSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  parent: (
    where?: ParentSubscriptionWhereInput
  ) => ParentSubscriptionPayloadSubscription;
  parentAuthInfo: (
    where?: ParentAuthInfoSubscriptionWhereInput
  ) => ParentAuthInfoSubscriptionPayloadSubscription;
  shortTerm: (
    where?: ShortTermSubscriptionWhereInput
  ) => ShortTermSubscriptionPayloadSubscription;
  student: (
    where?: StudentSubscriptionWhereInput
  ) => StudentSubscriptionPayloadSubscription;
  studentAuthInfo: (
    where?: StudentAuthInfoSubscriptionWhereInput
  ) => StudentAuthInfoSubscriptionPayloadSubscription;
  studentDetail: (
    where?: StudentDetailSubscriptionWhereInput
  ) => StudentDetailSubscriptionPayloadSubscription;
  subject: (
    where?: SubjectSubscriptionWhereInput
  ) => SubjectSubscriptionPayloadSubscription;
  tryOrder: (
    where?: TryOrderSubscriptionWhereInput
  ) => TryOrderSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  emerContact: (
    where?: emerContactSubscriptionWhereInput
  ) => emerContactSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AdminOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "UnionID_ASC"
  | "UnionID_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "email_ASC"
  | "email_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Day = "SUN" | "MON" | "TUE" | "WED" | "THU" | "FRI" | "SAT";

export type DetailTime = "MORN" | "NOON" | "AFTER";

export type AvalibelTimeOrderByInput =
  | "day_ASC"
  | "day_DESC"
  | "detail_ASC"
  | "detail_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Level = "PRIMARY" | "MIDDLE" | "MIDDLEHIGH" | "OTHER";

export type SubjectName =
  | "CHINESE"
  | "MATH"
  | "ENGLISH"
  | "PHYSICS"
  | "CHEMSTRY"
  | "BIOLOGY"
  | "HISTORY"
  | "GEOGRAPHY"
  | "OTHER";

export type Gender = "MALE" | "FEMALE";

export type SelectGender = "MALE" | "FEMALE" | "BOTH";

export type BasicTermInfoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "Level_ASC"
  | "Level_DESC"
  | "pay_ASC"
  | "pay_DESC"
  | "childGender_ASC"
  | "childGender_DESC"
  | "teacherGender_ASC"
  | "teacherGender_DESC"
  | "teacherReuqire_ASC"
  | "teacherReuqire_DESC"
  | "childStatus_ASC"
  | "childStatus_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type University = "HUST" | "WHU";

export type AuthStatus = "UNCOMMITED" | "AUTHCOMMITED" | "AUTHED" | "REJECTED";

export type SubjectOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Invitor = "STUDENT" | "PARENT";

export type InvitationStatus =
  | "REBACK"
  | "WAITING"
  | "ACCEPT"
  | "REJECTED"
  | "UNPAIED"
  | "PAIED"
  | "FINISHED";

export type OrderStatus = "PAIED" | "UNPAIED" | "FINISHED";

export type ParentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "UnionID_ASC"
  | "UnionID_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address_ASC"
  | "address_DESC"
  | "email_ASC"
  | "email_DESC"
  | "authStatus_ASC"
  | "authStatus_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "publish_ASC"
  | "publish_DESC";

export type StudentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "UnionID_ASC"
  | "UnionID_DESC"
  | "openid_ASC"
  | "openid_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "name_ASC"
  | "name_DESC"
  | "university_ASC"
  | "university_DESC"
  | "grades_ASC"
  | "grades_DESC"
  | "email_ASC"
  | "email_DESC"
  | "Gender_ASC"
  | "Gender_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "expectPay_ASC"
  | "expectPay_DESC"
  | "authStatus_ASC"
  | "authStatus_DESC"
  | "publish_ASC"
  | "publish_DESC";

export type InvitationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "invitor_ASC"
  | "invitor_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LongTermOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "lessonTime_ASC"
  | "lessonTime_DESC"
  | "days_ASC"
  | "days_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ParentAuthInfoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "UnionID_ASC"
  | "UnionID_DESC"
  | "res_ASC"
  | "res_DESC"
  | "info_ASC"
  | "info_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ShortTermOrderByInput =
  | "shortTermId_ASC"
  | "shortTermId_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StudentAuthInfoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "UnionID_ASC"
  | "UnionID_DESC"
  | "res_ASC"
  | "res_DESC"
  | "info_ASC"
  | "info_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StudentDetailOrderByInput =
  | "selfIntro_ASC"
  | "selfIntro_DESC"
  | "grades_ASC"
  | "grades_DESC"
  | "exprience_ASC"
  | "exprience_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type emerContactOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "relation_ASC"
  | "relation_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type tryOrderStatus =
  | "INIT"
  | "INFOCOMPLETE"
  | "PACK"
  | "SACK"
  | "CANCLED"
  | "FINISHED";

export type TryOrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "address_ASC"
  | "address_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "otherInfo_ASC"
  | "otherInfo_DESC"
  | "status_ASC"
  | "status_DESC"
  | "rejectInfo_ASC"
  | "rejectInfo_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "UnionID_ASC"
  | "UnionID_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AdminWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  UnionID?: String;
  name?: String;
  phone?: String;
  email?: String;
}>;

export interface AdminWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  UnionID?: String;
  UnionID_not?: String;
  UnionID_in?: String[] | String;
  UnionID_not_in?: String[] | String;
  UnionID_lt?: String;
  UnionID_lte?: String;
  UnionID_gt?: String;
  UnionID_gte?: String;
  UnionID_contains?: String;
  UnionID_not_contains?: String;
  UnionID_starts_with?: String;
  UnionID_not_starts_with?: String;
  UnionID_ends_with?: String;
  UnionID_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  AND?: AdminWhereInput[] | AdminWhereInput;
  OR?: AdminWhereInput[] | AdminWhereInput;
  NOT?: AdminWhereInput[] | AdminWhereInput;
}

export interface AvalibelTimeWhereInput {
  day?: Day;
  day_not?: Day;
  day_in?: Day[] | Day;
  day_not_in?: Day[] | Day;
  detail?: DetailTime;
  detail_not?: DetailTime;
  detail_in?: DetailTime[] | DetailTime;
  detail_not_in?: DetailTime[] | DetailTime;
  AND?: AvalibelTimeWhereInput[] | AvalibelTimeWhereInput;
  OR?: AvalibelTimeWhereInput[] | AvalibelTimeWhereInput;
  NOT?: AvalibelTimeWhereInput[] | AvalibelTimeWhereInput;
}

export type BasicTermInfoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BasicTermInfoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  Level?: Level;
  Level_not?: Level;
  Level_in?: Level[] | Level;
  Level_not_in?: Level[] | Level;
  pay?: Int;
  pay_not?: Int;
  pay_in?: Int[] | Int;
  pay_not_in?: Int[] | Int;
  pay_lt?: Int;
  pay_lte?: Int;
  pay_gt?: Int;
  pay_gte?: Int;
  childGender?: Gender;
  childGender_not?: Gender;
  childGender_in?: Gender[] | Gender;
  childGender_not_in?: Gender[] | Gender;
  teacherGender?: SelectGender;
  teacherGender_not?: SelectGender;
  teacherGender_in?: SelectGender[] | SelectGender;
  teacherGender_not_in?: SelectGender[] | SelectGender;
  teacherReuqire?: String;
  teacherReuqire_not?: String;
  teacherReuqire_in?: String[] | String;
  teacherReuqire_not_in?: String[] | String;
  teacherReuqire_lt?: String;
  teacherReuqire_lte?: String;
  teacherReuqire_gt?: String;
  teacherReuqire_gte?: String;
  teacherReuqire_contains?: String;
  teacherReuqire_not_contains?: String;
  teacherReuqire_starts_with?: String;
  teacherReuqire_not_starts_with?: String;
  teacherReuqire_ends_with?: String;
  teacherReuqire_not_ends_with?: String;
  childStatus?: String;
  childStatus_not?: String;
  childStatus_in?: String[] | String;
  childStatus_not_in?: String[] | String;
  childStatus_lt?: String;
  childStatus_lte?: String;
  childStatus_gt?: String;
  childStatus_gte?: String;
  childStatus_contains?: String;
  childStatus_not_contains?: String;
  childStatus_starts_with?: String;
  childStatus_not_starts_with?: String;
  childStatus_ends_with?: String;
  childStatus_not_ends_with?: String;
  longTerm?: LongTermWhereInput;
  shortTerm?: ShortTermWhereInput;
  AND?: BasicTermInfoWhereInput[] | BasicTermInfoWhereInput;
  OR?: BasicTermInfoWhereInput[] | BasicTermInfoWhereInput;
  NOT?: BasicTermInfoWhereInput[] | BasicTermInfoWhereInput;
}

export interface LongTermWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  lessonTime?: Int;
  lessonTime_not?: Int;
  lessonTime_in?: Int[] | Int;
  lessonTime_not_in?: Int[] | Int;
  lessonTime_lt?: Int;
  lessonTime_lte?: Int;
  lessonTime_gt?: Int;
  lessonTime_gte?: Int;
  days?: Int;
  days_not?: Int;
  days_in?: Int[] | Int;
  days_not_in?: Int[] | Int;
  days_lt?: Int;
  days_lte?: Int;
  days_gt?: Int;
  days_gte?: Int;
  timeList_every?: AvalibelTimeWhereInput;
  timeList_some?: AvalibelTimeWhereInput;
  timeList_none?: AvalibelTimeWhereInput;
  AND?: LongTermWhereInput[] | LongTermWhereInput;
  OR?: LongTermWhereInput[] | LongTermWhereInput;
  NOT?: LongTermWhereInput[] | LongTermWhereInput;
}

export interface ShortTermWhereInput {
  shortTermId?: ID_Input;
  shortTermId_not?: ID_Input;
  shortTermId_in?: ID_Input[] | ID_Input;
  shortTermId_not_in?: ID_Input[] | ID_Input;
  shortTermId_lt?: ID_Input;
  shortTermId_lte?: ID_Input;
  shortTermId_gt?: ID_Input;
  shortTermId_gte?: ID_Input;
  shortTermId_contains?: ID_Input;
  shortTermId_not_contains?: ID_Input;
  shortTermId_starts_with?: ID_Input;
  shortTermId_not_starts_with?: ID_Input;
  shortTermId_ends_with?: ID_Input;
  shortTermId_not_ends_with?: ID_Input;
  AND?: ShortTermWhereInput[] | ShortTermWhereInput;
  OR?: ShortTermWhereInput[] | ShortTermWhereInput;
  NOT?: ShortTermWhereInput[] | ShortTermWhereInput;
}

export type InvitationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SubjectWhereInput {
  name?: SubjectName;
  name_not?: SubjectName;
  name_in?: SubjectName[] | SubjectName;
  name_not_in?: SubjectName[] | SubjectName;
  AND?: SubjectWhereInput[] | SubjectWhereInput;
  OR?: SubjectWhereInput[] | SubjectWhereInput;
  NOT?: SubjectWhereInput[] | SubjectWhereInput;
}

export interface ParentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  UnionID?: String;
  UnionID_not?: String;
  UnionID_in?: String[] | String;
  UnionID_not_in?: String[] | String;
  UnionID_lt?: String;
  UnionID_lte?: String;
  UnionID_gt?: String;
  UnionID_gte?: String;
  UnionID_contains?: String;
  UnionID_not_contains?: String;
  UnionID_starts_with?: String;
  UnionID_not_starts_with?: String;
  UnionID_ends_with?: String;
  UnionID_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  authStatus?: AuthStatus;
  authStatus_not?: AuthStatus;
  authStatus_in?: AuthStatus[] | AuthStatus;
  authStatus_not_in?: AuthStatus[] | AuthStatus;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  starList_every?: StudentWhereInput;
  starList_some?: StudentWhereInput;
  starList_none?: StudentWhereInput;
  invitations_every?: InvitationWhereInput;
  invitations_some?: InvitationWhereInput;
  invitations_none?: InvitationWhereInput;
  order_every?: OrderWhereInput;
  order_some?: OrderWhereInput;
  order_none?: OrderWhereInput;
  publishTerm?: BasicTermInfoWhereInput;
  publish?: Boolean;
  publish_not?: Boolean;
  AND?: ParentWhereInput[] | ParentWhereInput;
  OR?: ParentWhereInput[] | ParentWhereInput;
  NOT?: ParentWhereInput[] | ParentWhereInput;
}

export interface StudentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  UnionID?: String;
  UnionID_not?: String;
  UnionID_in?: String[] | String;
  UnionID_not_in?: String[] | String;
  UnionID_lt?: String;
  UnionID_lte?: String;
  UnionID_gt?: String;
  UnionID_gte?: String;
  UnionID_contains?: String;
  UnionID_not_contains?: String;
  UnionID_starts_with?: String;
  UnionID_not_starts_with?: String;
  UnionID_ends_with?: String;
  UnionID_not_ends_with?: String;
  openid?: String;
  openid_not?: String;
  openid_in?: String[] | String;
  openid_not_in?: String[] | String;
  openid_lt?: String;
  openid_lte?: String;
  openid_gt?: String;
  openid_gte?: String;
  openid_contains?: String;
  openid_not_contains?: String;
  openid_starts_with?: String;
  openid_not_starts_with?: String;
  openid_ends_with?: String;
  openid_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  university?: University;
  university_not?: University;
  university_in?: University[] | University;
  university_not_in?: University[] | University;
  grades?: String;
  grades_not?: String;
  grades_in?: String[] | String;
  grades_not_in?: String[] | String;
  grades_lt?: String;
  grades_lte?: String;
  grades_gt?: String;
  grades_gte?: String;
  grades_contains?: String;
  grades_not_contains?: String;
  grades_starts_with?: String;
  grades_not_starts_with?: String;
  grades_ends_with?: String;
  grades_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  Gender?: Gender;
  Gender_not?: Gender;
  Gender_in?: Gender[] | Gender;
  Gender_not_in?: Gender[] | Gender;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  expectPay?: Int;
  expectPay_not?: Int;
  expectPay_in?: Int[] | Int;
  expectPay_not_in?: Int[] | Int;
  expectPay_lt?: Int;
  expectPay_lte?: Int;
  expectPay_gt?: Int;
  expectPay_gte?: Int;
  authStatus?: AuthStatus;
  authStatus_not?: AuthStatus;
  authStatus_in?: AuthStatus[] | AuthStatus;
  authStatus_not_in?: AuthStatus[] | AuthStatus;
  subjects_every?: SubjectWhereInput;
  subjects_some?: SubjectWhereInput;
  subjects_none?: SubjectWhereInput;
  starList_every?: ParentWhereInput;
  starList_some?: ParentWhereInput;
  starList_none?: ParentWhereInput;
  avalible_every?: AvalibelTimeWhereInput;
  avalible_some?: AvalibelTimeWhereInput;
  avalible_none?: AvalibelTimeWhereInput;
  studentDetail?: StudentDetailWhereInput;
  invitations_every?: InvitationWhereInput;
  invitations_some?: InvitationWhereInput;
  invitations_none?: InvitationWhereInput;
  order_every?: OrderWhereInput;
  order_some?: OrderWhereInput;
  order_none?: OrderWhereInput;
  publish?: Boolean;
  publish_not?: Boolean;
  AND?: StudentWhereInput[] | StudentWhereInput;
  OR?: StudentWhereInput[] | StudentWhereInput;
  NOT?: StudentWhereInput[] | StudentWhereInput;
}

export interface StudentDetailWhereInput {
  selfIntro?: String;
  selfIntro_not?: String;
  selfIntro_in?: String[] | String;
  selfIntro_not_in?: String[] | String;
  selfIntro_lt?: String;
  selfIntro_lte?: String;
  selfIntro_gt?: String;
  selfIntro_gte?: String;
  selfIntro_contains?: String;
  selfIntro_not_contains?: String;
  selfIntro_starts_with?: String;
  selfIntro_not_starts_with?: String;
  selfIntro_ends_with?: String;
  selfIntro_not_ends_with?: String;
  grades?: String;
  grades_not?: String;
  grades_in?: String[] | String;
  grades_not_in?: String[] | String;
  grades_lt?: String;
  grades_lte?: String;
  grades_gt?: String;
  grades_gte?: String;
  grades_contains?: String;
  grades_not_contains?: String;
  grades_starts_with?: String;
  grades_not_starts_with?: String;
  grades_ends_with?: String;
  grades_not_ends_with?: String;
  exprience?: String;
  exprience_not?: String;
  exprience_in?: String[] | String;
  exprience_not_in?: String[] | String;
  exprience_lt?: String;
  exprience_lte?: String;
  exprience_gt?: String;
  exprience_gte?: String;
  exprience_contains?: String;
  exprience_not_contains?: String;
  exprience_starts_with?: String;
  exprience_not_starts_with?: String;
  exprience_ends_with?: String;
  exprience_not_ends_with?: String;
  AND?: StudentDetailWhereInput[] | StudentDetailWhereInput;
  OR?: StudentDetailWhereInput[] | StudentDetailWhereInput;
  NOT?: StudentDetailWhereInput[] | StudentDetailWhereInput;
}

export interface InvitationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  student?: StudentWhereInput;
  parent?: ParentWhereInput;
  invitor?: Invitor;
  invitor_not?: Invitor;
  invitor_in?: Invitor[] | Invitor;
  invitor_not_in?: Invitor[] | Invitor;
  status?: InvitationStatus;
  status_not?: InvitationStatus;
  status_in?: InvitationStatus[] | InvitationStatus;
  status_not_in?: InvitationStatus[] | InvitationStatus;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: InvitationWhereInput[] | InvitationWhereInput;
  OR?: InvitationWhereInput[] | InvitationWhereInput;
  NOT?: InvitationWhereInput[] | InvitationWhereInput;
}

export interface OrderWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  stuednt?: StudentWhereInput;
  parent?: ParentWhereInput;
  status?: OrderStatus;
  status_not?: OrderStatus;
  status_in?: OrderStatus[] | OrderStatus;
  status_not_in?: OrderStatus[] | OrderStatus;
  AND?: OrderWhereInput[] | OrderWhereInput;
  OR?: OrderWhereInput[] | OrderWhereInput;
  NOT?: OrderWhereInput[] | OrderWhereInput;
}

export type LongTermWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type OrderWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ParentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  UnionID?: String;
  phone?: String;
  name?: String;
  email?: String;
}>;

export type ParentAuthInfoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  UnionID?: String;
}>;

export interface ParentAuthInfoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  parent?: ParentWhereInput;
  UnionID?: String;
  UnionID_not?: String;
  UnionID_in?: String[] | String;
  UnionID_not_in?: String[] | String;
  UnionID_lt?: String;
  UnionID_lte?: String;
  UnionID_gt?: String;
  UnionID_gte?: String;
  UnionID_contains?: String;
  UnionID_not_contains?: String;
  UnionID_starts_with?: String;
  UnionID_not_starts_with?: String;
  UnionID_ends_with?: String;
  UnionID_not_ends_with?: String;
  res?: AuthStatus;
  res_not?: AuthStatus;
  res_in?: AuthStatus[] | AuthStatus;
  res_not_in?: AuthStatus[] | AuthStatus;
  info?: String;
  info_not?: String;
  info_in?: String[] | String;
  info_not_in?: String[] | String;
  info_lt?: String;
  info_lte?: String;
  info_gt?: String;
  info_gte?: String;
  info_contains?: String;
  info_not_contains?: String;
  info_starts_with?: String;
  info_not_starts_with?: String;
  info_ends_with?: String;
  info_not_ends_with?: String;
  Auth?: AdminWhereInput;
  AND?: ParentAuthInfoWhereInput[] | ParentAuthInfoWhereInput;
  OR?: ParentAuthInfoWhereInput[] | ParentAuthInfoWhereInput;
  NOT?: ParentAuthInfoWhereInput[] | ParentAuthInfoWhereInput;
}

export type ShortTermWhereUniqueInput = AtLeastOne<{
  shortTermId: ID_Input;
}>;

export type StudentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  UnionID?: String;
  openid?: String;
  phone?: String;
  name?: String;
  email?: String;
}>;

export type StudentAuthInfoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  UnionID?: String;
}>;

export interface StudentAuthInfoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  UnionID?: String;
  UnionID_not?: String;
  UnionID_in?: String[] | String;
  UnionID_not_in?: String[] | String;
  UnionID_lt?: String;
  UnionID_lte?: String;
  UnionID_gt?: String;
  UnionID_gte?: String;
  UnionID_contains?: String;
  UnionID_not_contains?: String;
  UnionID_starts_with?: String;
  UnionID_not_starts_with?: String;
  UnionID_ends_with?: String;
  UnionID_not_ends_with?: String;
  student?: StudentWhereInput;
  res?: AuthStatus;
  res_not?: AuthStatus;
  res_in?: AuthStatus[] | AuthStatus;
  res_not_in?: AuthStatus[] | AuthStatus;
  info?: String;
  info_not?: String;
  info_in?: String[] | String;
  info_not_in?: String[] | String;
  info_lt?: String;
  info_lte?: String;
  info_gt?: String;
  info_gte?: String;
  info_contains?: String;
  info_not_contains?: String;
  info_starts_with?: String;
  info_not_starts_with?: String;
  info_ends_with?: String;
  info_not_ends_with?: String;
  Auth?: AdminWhereInput;
  AND?: StudentAuthInfoWhereInput[] | StudentAuthInfoWhereInput;
  OR?: StudentAuthInfoWhereInput[] | StudentAuthInfoWhereInput;
  NOT?: StudentAuthInfoWhereInput[] | StudentAuthInfoWhereInput;
}

export type TryOrderWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface emerContactWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  relation?: String;
  relation_not?: String;
  relation_in?: String[] | String;
  relation_not_in?: String[] | String;
  relation_lt?: String;
  relation_lte?: String;
  relation_gt?: String;
  relation_gte?: String;
  relation_contains?: String;
  relation_not_contains?: String;
  relation_starts_with?: String;
  relation_not_starts_with?: String;
  relation_ends_with?: String;
  relation_not_ends_with?: String;
  AND?: emerContactWhereInput[] | emerContactWhereInput;
  OR?: emerContactWhereInput[] | emerContactWhereInput;
  NOT?: emerContactWhereInput[] | emerContactWhereInput;
}

export interface TryOrderWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  student?: StudentWhereInput;
  parent?: ParentWhereInput;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  endTime?: DateTimeInput;
  endTime_not?: DateTimeInput;
  endTime_in?: DateTimeInput[] | DateTimeInput;
  endTime_not_in?: DateTimeInput[] | DateTimeInput;
  endTime_lt?: DateTimeInput;
  endTime_lte?: DateTimeInput;
  endTime_gt?: DateTimeInput;
  endTime_gte?: DateTimeInput;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  otherInfo?: String;
  otherInfo_not?: String;
  otherInfo_in?: String[] | String;
  otherInfo_not_in?: String[] | String;
  otherInfo_lt?: String;
  otherInfo_lte?: String;
  otherInfo_gt?: String;
  otherInfo_gte?: String;
  otherInfo_contains?: String;
  otherInfo_not_contains?: String;
  otherInfo_starts_with?: String;
  otherInfo_not_starts_with?: String;
  otherInfo_ends_with?: String;
  otherInfo_not_ends_with?: String;
  emerContact_every?: emerContactWhereInput;
  emerContact_some?: emerContactWhereInput;
  emerContact_none?: emerContactWhereInput;
  status?: tryOrderStatus;
  status_not?: tryOrderStatus;
  status_in?: tryOrderStatus[] | tryOrderStatus;
  status_not_in?: tryOrderStatus[] | tryOrderStatus;
  rejectInfo?: String;
  rejectInfo_not?: String;
  rejectInfo_in?: String[] | String;
  rejectInfo_not_in?: String[] | String;
  rejectInfo_lt?: String;
  rejectInfo_lte?: String;
  rejectInfo_gt?: String;
  rejectInfo_gte?: String;
  rejectInfo_contains?: String;
  rejectInfo_not_contains?: String;
  rejectInfo_starts_with?: String;
  rejectInfo_not_starts_with?: String;
  rejectInfo_ends_with?: String;
  rejectInfo_not_ends_with?: String;
  AND?: TryOrderWhereInput[] | TryOrderWhereInput;
  OR?: TryOrderWhereInput[] | TryOrderWhereInput;
  NOT?: TryOrderWhereInput[] | TryOrderWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  UnionID: String;
}>;

export interface UserWhereInput {
  UnionID?: String;
  UnionID_not?: String;
  UnionID_in?: String[] | String;
  UnionID_not_in?: String[] | String;
  UnionID_lt?: String;
  UnionID_lte?: String;
  UnionID_gt?: String;
  UnionID_gte?: String;
  UnionID_contains?: String;
  UnionID_not_contains?: String;
  UnionID_starts_with?: String;
  UnionID_not_starts_with?: String;
  UnionID_ends_with?: String;
  UnionID_not_ends_with?: String;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface AdminCreateInput {
  UnionID: String;
  name: String;
  phone: String;
  email: String;
}

export interface AdminUpdateInput {
  UnionID?: String;
  name?: String;
  phone?: String;
  email?: String;
}

export interface AdminUpdateManyMutationInput {
  UnionID?: String;
  name?: String;
  phone?: String;
  email?: String;
}

export interface AvalibelTimeCreateInput {
  day: Day;
  detail: DetailTime;
}

export interface AvalibelTimeUpdateManyMutationInput {
  day?: Day;
  detail?: DetailTime;
}

export interface BasicTermInfoCreateInput {
  Level: Level;
  subjects?: BasicTermInfoCreatesubjectsInput;
  pay?: Int;
  childGender?: Gender;
  teacherGender?: SelectGender;
  teacherReuqire?: String;
  childStatus?: String;
  longTerm?: LongTermCreateOneInput;
  shortTerm?: ShortTermCreateOneInput;
}

export interface BasicTermInfoCreatesubjectsInput {
  set?: SubjectName[] | SubjectName;
}

export interface LongTermCreateOneInput {
  create?: LongTermCreateInput;
  connect?: LongTermWhereUniqueInput;
}

export interface LongTermCreateInput {
  lessonTime?: Int;
  days?: Int;
  timeList?: AvalibelTimeCreateManyInput;
}

export interface AvalibelTimeCreateManyInput {
  create?: AvalibelTimeCreateInput[] | AvalibelTimeCreateInput;
}

export interface ShortTermCreateOneInput {
  create?: ShortTermCreateInput;
  connect?: ShortTermWhereUniqueInput;
}

export interface ShortTermCreateInput {
  shortTermId: ID_Input;
  timeList?: ShortTermCreatetimeListInput;
}

export interface ShortTermCreatetimeListInput {
  set?: DateTimeInput[] | DateTimeInput;
}

export interface BasicTermInfoUpdateInput {
  Level?: Level;
  subjects?: BasicTermInfoUpdatesubjectsInput;
  pay?: Int;
  childGender?: Gender;
  teacherGender?: SelectGender;
  teacherReuqire?: String;
  childStatus?: String;
  longTerm?: LongTermUpdateOneInput;
  shortTerm?: ShortTermUpdateOneInput;
}

export interface BasicTermInfoUpdatesubjectsInput {
  set?: SubjectName[] | SubjectName;
}

export interface LongTermUpdateOneInput {
  create?: LongTermCreateInput;
  update?: LongTermUpdateDataInput;
  upsert?: LongTermUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LongTermWhereUniqueInput;
}

export interface LongTermUpdateDataInput {
  lessonTime?: Int;
  days?: Int;
  timeList?: AvalibelTimeUpdateManyInput;
}

export interface AvalibelTimeUpdateManyInput {
  create?: AvalibelTimeCreateInput[] | AvalibelTimeCreateInput;
  deleteMany?: AvalibelTimeScalarWhereInput[] | AvalibelTimeScalarWhereInput;
  updateMany?:
    | AvalibelTimeUpdateManyWithWhereNestedInput[]
    | AvalibelTimeUpdateManyWithWhereNestedInput;
}

export interface AvalibelTimeScalarWhereInput {
  day?: Day;
  day_not?: Day;
  day_in?: Day[] | Day;
  day_not_in?: Day[] | Day;
  detail?: DetailTime;
  detail_not?: DetailTime;
  detail_in?: DetailTime[] | DetailTime;
  detail_not_in?: DetailTime[] | DetailTime;
  AND?: AvalibelTimeScalarWhereInput[] | AvalibelTimeScalarWhereInput;
  OR?: AvalibelTimeScalarWhereInput[] | AvalibelTimeScalarWhereInput;
  NOT?: AvalibelTimeScalarWhereInput[] | AvalibelTimeScalarWhereInput;
}

export interface AvalibelTimeUpdateManyWithWhereNestedInput {
  where: AvalibelTimeScalarWhereInput;
  data: AvalibelTimeUpdateManyDataInput;
}

export interface AvalibelTimeUpdateManyDataInput {
  day?: Day;
  detail?: DetailTime;
}

export interface LongTermUpsertNestedInput {
  update: LongTermUpdateDataInput;
  create: LongTermCreateInput;
}

export interface ShortTermUpdateOneInput {
  create?: ShortTermCreateInput;
  update?: ShortTermUpdateDataInput;
  upsert?: ShortTermUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ShortTermWhereUniqueInput;
}

export interface ShortTermUpdateDataInput {
  shortTermId?: ID_Input;
  timeList?: ShortTermUpdatetimeListInput;
}

export interface ShortTermUpdatetimeListInput {
  set?: DateTimeInput[] | DateTimeInput;
}

export interface ShortTermUpsertNestedInput {
  update: ShortTermUpdateDataInput;
  create: ShortTermCreateInput;
}

export interface BasicTermInfoUpdateManyMutationInput {
  Level?: Level;
  subjects?: BasicTermInfoUpdatesubjectsInput;
  pay?: Int;
  childGender?: Gender;
  teacherGender?: SelectGender;
  teacherReuqire?: String;
  childStatus?: String;
}

export interface InvitationCreateInput {
  student: StudentCreateOneWithoutInvitationsInput;
  parent: ParentCreateOneWithoutInvitationsInput;
  invitor: Invitor;
  status: InvitationStatus;
}

export interface StudentCreateOneWithoutInvitationsInput {
  create?: StudentCreateWithoutInvitationsInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudentCreateWithoutInvitationsInput {
  UnionID: String;
  openid: String;
  phone: String;
  name: String;
  university: University;
  grades: String;
  email: String;
  Gender?: Gender;
  expectPay?: Int;
  authStatus: AuthStatus;
  subjects?: SubjectCreateManyInput;
  starList?: ParentCreateManyWithoutStarListInput;
  avalible?: AvalibelTimeCreateManyInput;
  studentDetail?: StudentDetailCreateOneInput;
  order?: OrderCreateManyWithoutStuedntInput;
  publish?: Boolean;
}

export interface SubjectCreateManyInput {
  create?: SubjectCreateInput[] | SubjectCreateInput;
}

export interface SubjectCreateInput {
  name: SubjectName;
  level?: SubjectCreatelevelInput;
}

export interface SubjectCreatelevelInput {
  set?: Level[] | Level;
}

export interface ParentCreateManyWithoutStarListInput {
  create?:
    | ParentCreateWithoutStarListInput[]
    | ParentCreateWithoutStarListInput;
  connect?: ParentWhereUniqueInput[] | ParentWhereUniqueInput;
}

export interface ParentCreateWithoutStarListInput {
  UnionID: String;
  phone: String;
  name: String;
  address: String;
  email: String;
  authStatus: AuthStatus;
  invitations?: InvitationCreateManyWithoutParentInput;
  order?: OrderCreateManyWithoutParentInput;
  publishTerm: BasicTermInfoCreateOneInput;
  publish?: Boolean;
}

export interface InvitationCreateManyWithoutParentInput {
  create?:
    | InvitationCreateWithoutParentInput[]
    | InvitationCreateWithoutParentInput;
  connect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
}

export interface InvitationCreateWithoutParentInput {
  student: StudentCreateOneWithoutInvitationsInput;
  invitor: Invitor;
  status: InvitationStatus;
}

export interface OrderCreateManyWithoutParentInput {
  create?: OrderCreateWithoutParentInput[] | OrderCreateWithoutParentInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
}

export interface OrderCreateWithoutParentInput {
  stuednt: StudentCreateOneWithoutOrderInput;
  status: OrderStatus;
}

export interface StudentCreateOneWithoutOrderInput {
  create?: StudentCreateWithoutOrderInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudentCreateWithoutOrderInput {
  UnionID: String;
  openid: String;
  phone: String;
  name: String;
  university: University;
  grades: String;
  email: String;
  Gender?: Gender;
  expectPay?: Int;
  authStatus: AuthStatus;
  subjects?: SubjectCreateManyInput;
  starList?: ParentCreateManyWithoutStarListInput;
  avalible?: AvalibelTimeCreateManyInput;
  studentDetail?: StudentDetailCreateOneInput;
  invitations?: InvitationCreateManyWithoutStudentInput;
  publish?: Boolean;
}

export interface StudentDetailCreateOneInput {
  create?: StudentDetailCreateInput;
}

export interface StudentDetailCreateInput {
  selfIntro: String;
  grades: String;
  exprience: String;
  picture?: StudentDetailCreatepictureInput;
}

export interface StudentDetailCreatepictureInput {
  set?: String[] | String;
}

export interface InvitationCreateManyWithoutStudentInput {
  create?:
    | InvitationCreateWithoutStudentInput[]
    | InvitationCreateWithoutStudentInput;
  connect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
}

export interface InvitationCreateWithoutStudentInput {
  parent: ParentCreateOneWithoutInvitationsInput;
  invitor: Invitor;
  status: InvitationStatus;
}

export interface ParentCreateOneWithoutInvitationsInput {
  create?: ParentCreateWithoutInvitationsInput;
  connect?: ParentWhereUniqueInput;
}

export interface ParentCreateWithoutInvitationsInput {
  UnionID: String;
  phone: String;
  name: String;
  address: String;
  email: String;
  authStatus: AuthStatus;
  starList?: StudentCreateManyWithoutStarListInput;
  order?: OrderCreateManyWithoutParentInput;
  publishTerm: BasicTermInfoCreateOneInput;
  publish?: Boolean;
}

export interface StudentCreateManyWithoutStarListInput {
  create?:
    | StudentCreateWithoutStarListInput[]
    | StudentCreateWithoutStarListInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
}

export interface StudentCreateWithoutStarListInput {
  UnionID: String;
  openid: String;
  phone: String;
  name: String;
  university: University;
  grades: String;
  email: String;
  Gender?: Gender;
  expectPay?: Int;
  authStatus: AuthStatus;
  subjects?: SubjectCreateManyInput;
  avalible?: AvalibelTimeCreateManyInput;
  studentDetail?: StudentDetailCreateOneInput;
  invitations?: InvitationCreateManyWithoutStudentInput;
  order?: OrderCreateManyWithoutStuedntInput;
  publish?: Boolean;
}

export interface OrderCreateManyWithoutStuedntInput {
  create?: OrderCreateWithoutStuedntInput[] | OrderCreateWithoutStuedntInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
}

export interface OrderCreateWithoutStuedntInput {
  parent: ParentCreateOneWithoutOrderInput;
  status: OrderStatus;
}

export interface ParentCreateOneWithoutOrderInput {
  create?: ParentCreateWithoutOrderInput;
  connect?: ParentWhereUniqueInput;
}

export interface ParentCreateWithoutOrderInput {
  UnionID: String;
  phone: String;
  name: String;
  address: String;
  email: String;
  authStatus: AuthStatus;
  starList?: StudentCreateManyWithoutStarListInput;
  invitations?: InvitationCreateManyWithoutParentInput;
  publishTerm: BasicTermInfoCreateOneInput;
  publish?: Boolean;
}

export interface BasicTermInfoCreateOneInput {
  create?: BasicTermInfoCreateInput;
  connect?: BasicTermInfoWhereUniqueInput;
}

export interface InvitationUpdateInput {
  student?: StudentUpdateOneRequiredWithoutInvitationsInput;
  parent?: ParentUpdateOneRequiredWithoutInvitationsInput;
  invitor?: Invitor;
  status?: InvitationStatus;
}

export interface StudentUpdateOneRequiredWithoutInvitationsInput {
  create?: StudentCreateWithoutInvitationsInput;
  update?: StudentUpdateWithoutInvitationsDataInput;
  upsert?: StudentUpsertWithoutInvitationsInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudentUpdateWithoutInvitationsDataInput {
  UnionID?: String;
  openid?: String;
  phone?: String;
  name?: String;
  university?: University;
  grades?: String;
  email?: String;
  Gender?: Gender;
  expectPay?: Int;
  authStatus?: AuthStatus;
  subjects?: SubjectUpdateManyInput;
  starList?: ParentUpdateManyWithoutStarListInput;
  avalible?: AvalibelTimeUpdateManyInput;
  studentDetail?: StudentDetailUpdateOneInput;
  order?: OrderUpdateManyWithoutStuedntInput;
  publish?: Boolean;
}

export interface SubjectUpdateManyInput {
  create?: SubjectCreateInput[] | SubjectCreateInput;
  deleteMany?: SubjectScalarWhereInput[] | SubjectScalarWhereInput;
  updateMany?:
    | SubjectUpdateManyWithWhereNestedInput[]
    | SubjectUpdateManyWithWhereNestedInput;
}

export interface SubjectScalarWhereInput {
  name?: SubjectName;
  name_not?: SubjectName;
  name_in?: SubjectName[] | SubjectName;
  name_not_in?: SubjectName[] | SubjectName;
  AND?: SubjectScalarWhereInput[] | SubjectScalarWhereInput;
  OR?: SubjectScalarWhereInput[] | SubjectScalarWhereInput;
  NOT?: SubjectScalarWhereInput[] | SubjectScalarWhereInput;
}

export interface SubjectUpdateManyWithWhereNestedInput {
  where: SubjectScalarWhereInput;
  data: SubjectUpdateManyDataInput;
}

export interface SubjectUpdateManyDataInput {
  name?: SubjectName;
  level?: SubjectUpdatelevelInput;
}

export interface SubjectUpdatelevelInput {
  set?: Level[] | Level;
}

export interface ParentUpdateManyWithoutStarListInput {
  create?:
    | ParentCreateWithoutStarListInput[]
    | ParentCreateWithoutStarListInput;
  delete?: ParentWhereUniqueInput[] | ParentWhereUniqueInput;
  connect?: ParentWhereUniqueInput[] | ParentWhereUniqueInput;
  disconnect?: ParentWhereUniqueInput[] | ParentWhereUniqueInput;
  update?:
    | ParentUpdateWithWhereUniqueWithoutStarListInput[]
    | ParentUpdateWithWhereUniqueWithoutStarListInput;
  upsert?:
    | ParentUpsertWithWhereUniqueWithoutStarListInput[]
    | ParentUpsertWithWhereUniqueWithoutStarListInput;
  deleteMany?: ParentScalarWhereInput[] | ParentScalarWhereInput;
  updateMany?:
    | ParentUpdateManyWithWhereNestedInput[]
    | ParentUpdateManyWithWhereNestedInput;
}

export interface ParentUpdateWithWhereUniqueWithoutStarListInput {
  where: ParentWhereUniqueInput;
  data: ParentUpdateWithoutStarListDataInput;
}

export interface ParentUpdateWithoutStarListDataInput {
  UnionID?: String;
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  authStatus?: AuthStatus;
  invitations?: InvitationUpdateManyWithoutParentInput;
  order?: OrderUpdateManyWithoutParentInput;
  publishTerm?: BasicTermInfoUpdateOneRequiredInput;
  publish?: Boolean;
}

export interface InvitationUpdateManyWithoutParentInput {
  create?:
    | InvitationCreateWithoutParentInput[]
    | InvitationCreateWithoutParentInput;
  delete?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  connect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  disconnect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  update?:
    | InvitationUpdateWithWhereUniqueWithoutParentInput[]
    | InvitationUpdateWithWhereUniqueWithoutParentInput;
  upsert?:
    | InvitationUpsertWithWhereUniqueWithoutParentInput[]
    | InvitationUpsertWithWhereUniqueWithoutParentInput;
  deleteMany?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
  updateMany?:
    | InvitationUpdateManyWithWhereNestedInput[]
    | InvitationUpdateManyWithWhereNestedInput;
}

export interface InvitationUpdateWithWhereUniqueWithoutParentInput {
  where: InvitationWhereUniqueInput;
  data: InvitationUpdateWithoutParentDataInput;
}

export interface InvitationUpdateWithoutParentDataInput {
  student?: StudentUpdateOneRequiredWithoutInvitationsInput;
  invitor?: Invitor;
  status?: InvitationStatus;
}

export interface InvitationUpsertWithWhereUniqueWithoutParentInput {
  where: InvitationWhereUniqueInput;
  update: InvitationUpdateWithoutParentDataInput;
  create: InvitationCreateWithoutParentInput;
}

export interface InvitationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  invitor?: Invitor;
  invitor_not?: Invitor;
  invitor_in?: Invitor[] | Invitor;
  invitor_not_in?: Invitor[] | Invitor;
  status?: InvitationStatus;
  status_not?: InvitationStatus;
  status_in?: InvitationStatus[] | InvitationStatus;
  status_not_in?: InvitationStatus[] | InvitationStatus;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
  OR?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
  NOT?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
}

export interface InvitationUpdateManyWithWhereNestedInput {
  where: InvitationScalarWhereInput;
  data: InvitationUpdateManyDataInput;
}

export interface InvitationUpdateManyDataInput {
  invitor?: Invitor;
  status?: InvitationStatus;
}

export interface OrderUpdateManyWithoutParentInput {
  create?: OrderCreateWithoutParentInput[] | OrderCreateWithoutParentInput;
  delete?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  disconnect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  update?:
    | OrderUpdateWithWhereUniqueWithoutParentInput[]
    | OrderUpdateWithWhereUniqueWithoutParentInput;
  upsert?:
    | OrderUpsertWithWhereUniqueWithoutParentInput[]
    | OrderUpsertWithWhereUniqueWithoutParentInput;
  deleteMany?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  updateMany?:
    | OrderUpdateManyWithWhereNestedInput[]
    | OrderUpdateManyWithWhereNestedInput;
}

export interface OrderUpdateWithWhereUniqueWithoutParentInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutParentDataInput;
}

export interface OrderUpdateWithoutParentDataInput {
  stuednt?: StudentUpdateOneRequiredWithoutOrderInput;
  status?: OrderStatus;
}

export interface StudentUpdateOneRequiredWithoutOrderInput {
  create?: StudentCreateWithoutOrderInput;
  update?: StudentUpdateWithoutOrderDataInput;
  upsert?: StudentUpsertWithoutOrderInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudentUpdateWithoutOrderDataInput {
  UnionID?: String;
  openid?: String;
  phone?: String;
  name?: String;
  university?: University;
  grades?: String;
  email?: String;
  Gender?: Gender;
  expectPay?: Int;
  authStatus?: AuthStatus;
  subjects?: SubjectUpdateManyInput;
  starList?: ParentUpdateManyWithoutStarListInput;
  avalible?: AvalibelTimeUpdateManyInput;
  studentDetail?: StudentDetailUpdateOneInput;
  invitations?: InvitationUpdateManyWithoutStudentInput;
  publish?: Boolean;
}

export interface StudentDetailUpdateOneInput {
  create?: StudentDetailCreateInput;
  update?: StudentDetailUpdateDataInput;
  upsert?: StudentDetailUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface StudentDetailUpdateDataInput {
  selfIntro?: String;
  grades?: String;
  exprience?: String;
  picture?: StudentDetailUpdatepictureInput;
}

export interface StudentDetailUpdatepictureInput {
  set?: String[] | String;
}

export interface StudentDetailUpsertNestedInput {
  update: StudentDetailUpdateDataInput;
  create: StudentDetailCreateInput;
}

export interface InvitationUpdateManyWithoutStudentInput {
  create?:
    | InvitationCreateWithoutStudentInput[]
    | InvitationCreateWithoutStudentInput;
  delete?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  connect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  disconnect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  update?:
    | InvitationUpdateWithWhereUniqueWithoutStudentInput[]
    | InvitationUpdateWithWhereUniqueWithoutStudentInput;
  upsert?:
    | InvitationUpsertWithWhereUniqueWithoutStudentInput[]
    | InvitationUpsertWithWhereUniqueWithoutStudentInput;
  deleteMany?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
  updateMany?:
    | InvitationUpdateManyWithWhereNestedInput[]
    | InvitationUpdateManyWithWhereNestedInput;
}

export interface InvitationUpdateWithWhereUniqueWithoutStudentInput {
  where: InvitationWhereUniqueInput;
  data: InvitationUpdateWithoutStudentDataInput;
}

export interface InvitationUpdateWithoutStudentDataInput {
  parent?: ParentUpdateOneRequiredWithoutInvitationsInput;
  invitor?: Invitor;
  status?: InvitationStatus;
}

export interface ParentUpdateOneRequiredWithoutInvitationsInput {
  create?: ParentCreateWithoutInvitationsInput;
  update?: ParentUpdateWithoutInvitationsDataInput;
  upsert?: ParentUpsertWithoutInvitationsInput;
  connect?: ParentWhereUniqueInput;
}

export interface ParentUpdateWithoutInvitationsDataInput {
  UnionID?: String;
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  authStatus?: AuthStatus;
  starList?: StudentUpdateManyWithoutStarListInput;
  order?: OrderUpdateManyWithoutParentInput;
  publishTerm?: BasicTermInfoUpdateOneRequiredInput;
  publish?: Boolean;
}

export interface StudentUpdateManyWithoutStarListInput {
  create?:
    | StudentCreateWithoutStarListInput[]
    | StudentCreateWithoutStarListInput;
  delete?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  disconnect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  update?:
    | StudentUpdateWithWhereUniqueWithoutStarListInput[]
    | StudentUpdateWithWhereUniqueWithoutStarListInput;
  upsert?:
    | StudentUpsertWithWhereUniqueWithoutStarListInput[]
    | StudentUpsertWithWhereUniqueWithoutStarListInput;
  deleteMany?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  updateMany?:
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput;
}

export interface StudentUpdateWithWhereUniqueWithoutStarListInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateWithoutStarListDataInput;
}

export interface StudentUpdateWithoutStarListDataInput {
  UnionID?: String;
  openid?: String;
  phone?: String;
  name?: String;
  university?: University;
  grades?: String;
  email?: String;
  Gender?: Gender;
  expectPay?: Int;
  authStatus?: AuthStatus;
  subjects?: SubjectUpdateManyInput;
  avalible?: AvalibelTimeUpdateManyInput;
  studentDetail?: StudentDetailUpdateOneInput;
  invitations?: InvitationUpdateManyWithoutStudentInput;
  order?: OrderUpdateManyWithoutStuedntInput;
  publish?: Boolean;
}

export interface OrderUpdateManyWithoutStuedntInput {
  create?: OrderCreateWithoutStuedntInput[] | OrderCreateWithoutStuedntInput;
  delete?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  disconnect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  update?:
    | OrderUpdateWithWhereUniqueWithoutStuedntInput[]
    | OrderUpdateWithWhereUniqueWithoutStuedntInput;
  upsert?:
    | OrderUpsertWithWhereUniqueWithoutStuedntInput[]
    | OrderUpsertWithWhereUniqueWithoutStuedntInput;
  deleteMany?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  updateMany?:
    | OrderUpdateManyWithWhereNestedInput[]
    | OrderUpdateManyWithWhereNestedInput;
}

export interface OrderUpdateWithWhereUniqueWithoutStuedntInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutStuedntDataInput;
}

export interface OrderUpdateWithoutStuedntDataInput {
  parent?: ParentUpdateOneRequiredWithoutOrderInput;
  status?: OrderStatus;
}

export interface ParentUpdateOneRequiredWithoutOrderInput {
  create?: ParentCreateWithoutOrderInput;
  update?: ParentUpdateWithoutOrderDataInput;
  upsert?: ParentUpsertWithoutOrderInput;
  connect?: ParentWhereUniqueInput;
}

export interface ParentUpdateWithoutOrderDataInput {
  UnionID?: String;
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  authStatus?: AuthStatus;
  starList?: StudentUpdateManyWithoutStarListInput;
  invitations?: InvitationUpdateManyWithoutParentInput;
  publishTerm?: BasicTermInfoUpdateOneRequiredInput;
  publish?: Boolean;
}

export interface BasicTermInfoUpdateOneRequiredInput {
  create?: BasicTermInfoCreateInput;
  update?: BasicTermInfoUpdateDataInput;
  upsert?: BasicTermInfoUpsertNestedInput;
  connect?: BasicTermInfoWhereUniqueInput;
}

export interface BasicTermInfoUpdateDataInput {
  Level?: Level;
  subjects?: BasicTermInfoUpdatesubjectsInput;
  pay?: Int;
  childGender?: Gender;
  teacherGender?: SelectGender;
  teacherReuqire?: String;
  childStatus?: String;
  longTerm?: LongTermUpdateOneInput;
  shortTerm?: ShortTermUpdateOneInput;
}

export interface BasicTermInfoUpsertNestedInput {
  update: BasicTermInfoUpdateDataInput;
  create: BasicTermInfoCreateInput;
}

export interface ParentUpsertWithoutOrderInput {
  update: ParentUpdateWithoutOrderDataInput;
  create: ParentCreateWithoutOrderInput;
}

export interface OrderUpsertWithWhereUniqueWithoutStuedntInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutStuedntDataInput;
  create: OrderCreateWithoutStuedntInput;
}

export interface OrderScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: OrderStatus;
  status_not?: OrderStatus;
  status_in?: OrderStatus[] | OrderStatus;
  status_not_in?: OrderStatus[] | OrderStatus;
  AND?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  OR?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  NOT?: OrderScalarWhereInput[] | OrderScalarWhereInput;
}

export interface OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput;
  data: OrderUpdateManyDataInput;
}

export interface OrderUpdateManyDataInput {
  status?: OrderStatus;
}

export interface StudentUpsertWithWhereUniqueWithoutStarListInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateWithoutStarListDataInput;
  create: StudentCreateWithoutStarListInput;
}

export interface StudentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  UnionID?: String;
  UnionID_not?: String;
  UnionID_in?: String[] | String;
  UnionID_not_in?: String[] | String;
  UnionID_lt?: String;
  UnionID_lte?: String;
  UnionID_gt?: String;
  UnionID_gte?: String;
  UnionID_contains?: String;
  UnionID_not_contains?: String;
  UnionID_starts_with?: String;
  UnionID_not_starts_with?: String;
  UnionID_ends_with?: String;
  UnionID_not_ends_with?: String;
  openid?: String;
  openid_not?: String;
  openid_in?: String[] | String;
  openid_not_in?: String[] | String;
  openid_lt?: String;
  openid_lte?: String;
  openid_gt?: String;
  openid_gte?: String;
  openid_contains?: String;
  openid_not_contains?: String;
  openid_starts_with?: String;
  openid_not_starts_with?: String;
  openid_ends_with?: String;
  openid_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  university?: University;
  university_not?: University;
  university_in?: University[] | University;
  university_not_in?: University[] | University;
  grades?: String;
  grades_not?: String;
  grades_in?: String[] | String;
  grades_not_in?: String[] | String;
  grades_lt?: String;
  grades_lte?: String;
  grades_gt?: String;
  grades_gte?: String;
  grades_contains?: String;
  grades_not_contains?: String;
  grades_starts_with?: String;
  grades_not_starts_with?: String;
  grades_ends_with?: String;
  grades_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  Gender?: Gender;
  Gender_not?: Gender;
  Gender_in?: Gender[] | Gender;
  Gender_not_in?: Gender[] | Gender;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  expectPay?: Int;
  expectPay_not?: Int;
  expectPay_in?: Int[] | Int;
  expectPay_not_in?: Int[] | Int;
  expectPay_lt?: Int;
  expectPay_lte?: Int;
  expectPay_gt?: Int;
  expectPay_gte?: Int;
  authStatus?: AuthStatus;
  authStatus_not?: AuthStatus;
  authStatus_in?: AuthStatus[] | AuthStatus;
  authStatus_not_in?: AuthStatus[] | AuthStatus;
  publish?: Boolean;
  publish_not?: Boolean;
  AND?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  OR?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  NOT?: StudentScalarWhereInput[] | StudentScalarWhereInput;
}

export interface StudentUpdateManyWithWhereNestedInput {
  where: StudentScalarWhereInput;
  data: StudentUpdateManyDataInput;
}

export interface StudentUpdateManyDataInput {
  UnionID?: String;
  openid?: String;
  phone?: String;
  name?: String;
  university?: University;
  grades?: String;
  email?: String;
  Gender?: Gender;
  expectPay?: Int;
  authStatus?: AuthStatus;
  publish?: Boolean;
}

export interface ParentUpsertWithoutInvitationsInput {
  update: ParentUpdateWithoutInvitationsDataInput;
  create: ParentCreateWithoutInvitationsInput;
}

export interface InvitationUpsertWithWhereUniqueWithoutStudentInput {
  where: InvitationWhereUniqueInput;
  update: InvitationUpdateWithoutStudentDataInput;
  create: InvitationCreateWithoutStudentInput;
}

export interface StudentUpsertWithoutOrderInput {
  update: StudentUpdateWithoutOrderDataInput;
  create: StudentCreateWithoutOrderInput;
}

export interface OrderUpsertWithWhereUniqueWithoutParentInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutParentDataInput;
  create: OrderCreateWithoutParentInput;
}

export interface ParentUpsertWithWhereUniqueWithoutStarListInput {
  where: ParentWhereUniqueInput;
  update: ParentUpdateWithoutStarListDataInput;
  create: ParentCreateWithoutStarListInput;
}

export interface ParentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  UnionID?: String;
  UnionID_not?: String;
  UnionID_in?: String[] | String;
  UnionID_not_in?: String[] | String;
  UnionID_lt?: String;
  UnionID_lte?: String;
  UnionID_gt?: String;
  UnionID_gte?: String;
  UnionID_contains?: String;
  UnionID_not_contains?: String;
  UnionID_starts_with?: String;
  UnionID_not_starts_with?: String;
  UnionID_ends_with?: String;
  UnionID_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  authStatus?: AuthStatus;
  authStatus_not?: AuthStatus;
  authStatus_in?: AuthStatus[] | AuthStatus;
  authStatus_not_in?: AuthStatus[] | AuthStatus;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  publish?: Boolean;
  publish_not?: Boolean;
  AND?: ParentScalarWhereInput[] | ParentScalarWhereInput;
  OR?: ParentScalarWhereInput[] | ParentScalarWhereInput;
  NOT?: ParentScalarWhereInput[] | ParentScalarWhereInput;
}

export interface ParentUpdateManyWithWhereNestedInput {
  where: ParentScalarWhereInput;
  data: ParentUpdateManyDataInput;
}

export interface ParentUpdateManyDataInput {
  UnionID?: String;
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  authStatus?: AuthStatus;
  publish?: Boolean;
}

export interface StudentUpsertWithoutInvitationsInput {
  update: StudentUpdateWithoutInvitationsDataInput;
  create: StudentCreateWithoutInvitationsInput;
}

export interface InvitationUpdateManyMutationInput {
  invitor?: Invitor;
  status?: InvitationStatus;
}

export interface LongTermUpdateInput {
  lessonTime?: Int;
  days?: Int;
  timeList?: AvalibelTimeUpdateManyInput;
}

export interface LongTermUpdateManyMutationInput {
  lessonTime?: Int;
  days?: Int;
}

export interface OrderCreateInput {
  stuednt: StudentCreateOneWithoutOrderInput;
  parent: ParentCreateOneWithoutOrderInput;
  status: OrderStatus;
}

export interface OrderUpdateInput {
  stuednt?: StudentUpdateOneRequiredWithoutOrderInput;
  parent?: ParentUpdateOneRequiredWithoutOrderInput;
  status?: OrderStatus;
}

export interface OrderUpdateManyMutationInput {
  status?: OrderStatus;
}

export interface ParentCreateInput {
  UnionID: String;
  phone: String;
  name: String;
  address: String;
  email: String;
  authStatus: AuthStatus;
  starList?: StudentCreateManyWithoutStarListInput;
  invitations?: InvitationCreateManyWithoutParentInput;
  order?: OrderCreateManyWithoutParentInput;
  publishTerm: BasicTermInfoCreateOneInput;
  publish?: Boolean;
}

export interface ParentUpdateInput {
  UnionID?: String;
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  authStatus?: AuthStatus;
  starList?: StudentUpdateManyWithoutStarListInput;
  invitations?: InvitationUpdateManyWithoutParentInput;
  order?: OrderUpdateManyWithoutParentInput;
  publishTerm?: BasicTermInfoUpdateOneRequiredInput;
  publish?: Boolean;
}

export interface ParentUpdateManyMutationInput {
  UnionID?: String;
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  authStatus?: AuthStatus;
  publish?: Boolean;
}

export interface ParentAuthInfoCreateInput {
  parent: ParentCreateOneInput;
  UnionID: String;
  sourceUrl?: ParentAuthInfoCreatesourceUrlInput;
  res: AuthStatus;
  info?: String;
  Auth?: AdminCreateOneInput;
}

export interface ParentCreateOneInput {
  create?: ParentCreateInput;
  connect?: ParentWhereUniqueInput;
}

export interface ParentAuthInfoCreatesourceUrlInput {
  set?: String[] | String;
}

export interface AdminCreateOneInput {
  create?: AdminCreateInput;
  connect?: AdminWhereUniqueInput;
}

export interface ParentAuthInfoUpdateInput {
  parent?: ParentUpdateOneRequiredInput;
  UnionID?: String;
  sourceUrl?: ParentAuthInfoUpdatesourceUrlInput;
  res?: AuthStatus;
  info?: String;
  Auth?: AdminUpdateOneInput;
}

export interface ParentUpdateOneRequiredInput {
  create?: ParentCreateInput;
  update?: ParentUpdateDataInput;
  upsert?: ParentUpsertNestedInput;
  connect?: ParentWhereUniqueInput;
}

export interface ParentUpdateDataInput {
  UnionID?: String;
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  authStatus?: AuthStatus;
  starList?: StudentUpdateManyWithoutStarListInput;
  invitations?: InvitationUpdateManyWithoutParentInput;
  order?: OrderUpdateManyWithoutParentInput;
  publishTerm?: BasicTermInfoUpdateOneRequiredInput;
  publish?: Boolean;
}

export interface ParentUpsertNestedInput {
  update: ParentUpdateDataInput;
  create: ParentCreateInput;
}

export interface ParentAuthInfoUpdatesourceUrlInput {
  set?: String[] | String;
}

export interface AdminUpdateOneInput {
  create?: AdminCreateInput;
  update?: AdminUpdateDataInput;
  upsert?: AdminUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AdminWhereUniqueInput;
}

export interface AdminUpdateDataInput {
  UnionID?: String;
  name?: String;
  phone?: String;
  email?: String;
}

export interface AdminUpsertNestedInput {
  update: AdminUpdateDataInput;
  create: AdminCreateInput;
}

export interface ParentAuthInfoUpdateManyMutationInput {
  UnionID?: String;
  sourceUrl?: ParentAuthInfoUpdatesourceUrlInput;
  res?: AuthStatus;
  info?: String;
}

export interface ShortTermUpdateInput {
  shortTermId?: ID_Input;
  timeList?: ShortTermUpdatetimeListInput;
}

export interface ShortTermUpdateManyMutationInput {
  shortTermId?: ID_Input;
  timeList?: ShortTermUpdatetimeListInput;
}

export interface StudentCreateInput {
  UnionID: String;
  openid: String;
  phone: String;
  name: String;
  university: University;
  grades: String;
  email: String;
  Gender?: Gender;
  expectPay?: Int;
  authStatus: AuthStatus;
  subjects?: SubjectCreateManyInput;
  starList?: ParentCreateManyWithoutStarListInput;
  avalible?: AvalibelTimeCreateManyInput;
  studentDetail?: StudentDetailCreateOneInput;
  invitations?: InvitationCreateManyWithoutStudentInput;
  order?: OrderCreateManyWithoutStuedntInput;
  publish?: Boolean;
}

export interface StudentUpdateInput {
  UnionID?: String;
  openid?: String;
  phone?: String;
  name?: String;
  university?: University;
  grades?: String;
  email?: String;
  Gender?: Gender;
  expectPay?: Int;
  authStatus?: AuthStatus;
  subjects?: SubjectUpdateManyInput;
  starList?: ParentUpdateManyWithoutStarListInput;
  avalible?: AvalibelTimeUpdateManyInput;
  studentDetail?: StudentDetailUpdateOneInput;
  invitations?: InvitationUpdateManyWithoutStudentInput;
  order?: OrderUpdateManyWithoutStuedntInput;
  publish?: Boolean;
}

export interface StudentUpdateManyMutationInput {
  UnionID?: String;
  openid?: String;
  phone?: String;
  name?: String;
  university?: University;
  grades?: String;
  email?: String;
  Gender?: Gender;
  expectPay?: Int;
  authStatus?: AuthStatus;
  publish?: Boolean;
}

export interface StudentAuthInfoCreateInput {
  UnionID: String;
  student: StudentCreateOneInput;
  sourceUrl?: StudentAuthInfoCreatesourceUrlInput;
  res: AuthStatus;
  info?: String;
  Auth?: AdminCreateOneInput;
}

export interface StudentCreateOneInput {
  create?: StudentCreateInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudentAuthInfoCreatesourceUrlInput {
  set?: String[] | String;
}

export interface StudentAuthInfoUpdateInput {
  UnionID?: String;
  student?: StudentUpdateOneRequiredInput;
  sourceUrl?: StudentAuthInfoUpdatesourceUrlInput;
  res?: AuthStatus;
  info?: String;
  Auth?: AdminUpdateOneInput;
}

export interface StudentUpdateOneRequiredInput {
  create?: StudentCreateInput;
  update?: StudentUpdateDataInput;
  upsert?: StudentUpsertNestedInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudentUpdateDataInput {
  UnionID?: String;
  openid?: String;
  phone?: String;
  name?: String;
  university?: University;
  grades?: String;
  email?: String;
  Gender?: Gender;
  expectPay?: Int;
  authStatus?: AuthStatus;
  subjects?: SubjectUpdateManyInput;
  starList?: ParentUpdateManyWithoutStarListInput;
  avalible?: AvalibelTimeUpdateManyInput;
  studentDetail?: StudentDetailUpdateOneInput;
  invitations?: InvitationUpdateManyWithoutStudentInput;
  order?: OrderUpdateManyWithoutStuedntInput;
  publish?: Boolean;
}

export interface StudentUpsertNestedInput {
  update: StudentUpdateDataInput;
  create: StudentCreateInput;
}

export interface StudentAuthInfoUpdatesourceUrlInput {
  set?: String[] | String;
}

export interface StudentAuthInfoUpdateManyMutationInput {
  UnionID?: String;
  sourceUrl?: StudentAuthInfoUpdatesourceUrlInput;
  res?: AuthStatus;
  info?: String;
}

export interface StudentDetailUpdateManyMutationInput {
  selfIntro?: String;
  grades?: String;
  exprience?: String;
  picture?: StudentDetailUpdatepictureInput;
}

export interface SubjectUpdateManyMutationInput {
  name?: SubjectName;
  level?: SubjectUpdatelevelInput;
}

export interface TryOrderCreateInput {
  student: StudentCreateOneInput;
  parent: ParentCreateOneInput;
  address: String;
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  phone?: String;
  otherInfo?: String;
  emerContact?: emerContactCreateManyInput;
  status: tryOrderStatus;
  rejectInfo?: String;
}

export interface emerContactCreateManyInput {
  create?: emerContactCreateInput[] | emerContactCreateInput;
}

export interface emerContactCreateInput {
  name: String;
  phone: String;
  relation: String;
}

export interface TryOrderUpdateInput {
  student?: StudentUpdateOneRequiredInput;
  parent?: ParentUpdateOneRequiredInput;
  address?: String;
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  phone?: String;
  otherInfo?: String;
  emerContact?: emerContactUpdateManyInput;
  status?: tryOrderStatus;
  rejectInfo?: String;
}

export interface emerContactUpdateManyInput {
  create?: emerContactCreateInput[] | emerContactCreateInput;
  deleteMany?: emerContactScalarWhereInput[] | emerContactScalarWhereInput;
  updateMany?:
    | emerContactUpdateManyWithWhereNestedInput[]
    | emerContactUpdateManyWithWhereNestedInput;
}

export interface emerContactScalarWhereInput {
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  relation?: String;
  relation_not?: String;
  relation_in?: String[] | String;
  relation_not_in?: String[] | String;
  relation_lt?: String;
  relation_lte?: String;
  relation_gt?: String;
  relation_gte?: String;
  relation_contains?: String;
  relation_not_contains?: String;
  relation_starts_with?: String;
  relation_not_starts_with?: String;
  relation_ends_with?: String;
  relation_not_ends_with?: String;
  AND?: emerContactScalarWhereInput[] | emerContactScalarWhereInput;
  OR?: emerContactScalarWhereInput[] | emerContactScalarWhereInput;
  NOT?: emerContactScalarWhereInput[] | emerContactScalarWhereInput;
}

export interface emerContactUpdateManyWithWhereNestedInput {
  where: emerContactScalarWhereInput;
  data: emerContactUpdateManyDataInput;
}

export interface emerContactUpdateManyDataInput {
  name?: String;
  phone?: String;
  relation?: String;
}

export interface TryOrderUpdateManyMutationInput {
  address?: String;
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  phone?: String;
  otherInfo?: String;
  status?: tryOrderStatus;
  rejectInfo?: String;
}

export interface UserCreateInput {
  UnionID: String;
}

export interface UserUpdateInput {
  UnionID?: String;
}

export interface UserUpdateManyMutationInput {
  UnionID?: String;
}

export interface emerContactUpdateManyMutationInput {
  name?: String;
  phone?: String;
  relation?: String;
}

export interface AdminSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AdminWhereInput;
  AND?: AdminSubscriptionWhereInput[] | AdminSubscriptionWhereInput;
  OR?: AdminSubscriptionWhereInput[] | AdminSubscriptionWhereInput;
  NOT?: AdminSubscriptionWhereInput[] | AdminSubscriptionWhereInput;
}

export interface AvalibelTimeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AvalibelTimeWhereInput;
  AND?:
    | AvalibelTimeSubscriptionWhereInput[]
    | AvalibelTimeSubscriptionWhereInput;
  OR?:
    | AvalibelTimeSubscriptionWhereInput[]
    | AvalibelTimeSubscriptionWhereInput;
  NOT?:
    | AvalibelTimeSubscriptionWhereInput[]
    | AvalibelTimeSubscriptionWhereInput;
}

export interface BasicTermInfoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BasicTermInfoWhereInput;
  AND?:
    | BasicTermInfoSubscriptionWhereInput[]
    | BasicTermInfoSubscriptionWhereInput;
  OR?:
    | BasicTermInfoSubscriptionWhereInput[]
    | BasicTermInfoSubscriptionWhereInput;
  NOT?:
    | BasicTermInfoSubscriptionWhereInput[]
    | BasicTermInfoSubscriptionWhereInput;
}

export interface InvitationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InvitationWhereInput;
  AND?: InvitationSubscriptionWhereInput[] | InvitationSubscriptionWhereInput;
  OR?: InvitationSubscriptionWhereInput[] | InvitationSubscriptionWhereInput;
  NOT?: InvitationSubscriptionWhereInput[] | InvitationSubscriptionWhereInput;
}

export interface LongTermSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LongTermWhereInput;
  AND?: LongTermSubscriptionWhereInput[] | LongTermSubscriptionWhereInput;
  OR?: LongTermSubscriptionWhereInput[] | LongTermSubscriptionWhereInput;
  NOT?: LongTermSubscriptionWhereInput[] | LongTermSubscriptionWhereInput;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrderWhereInput;
  AND?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
  OR?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
  NOT?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
}

export interface ParentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ParentWhereInput;
  AND?: ParentSubscriptionWhereInput[] | ParentSubscriptionWhereInput;
  OR?: ParentSubscriptionWhereInput[] | ParentSubscriptionWhereInput;
  NOT?: ParentSubscriptionWhereInput[] | ParentSubscriptionWhereInput;
}

export interface ParentAuthInfoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ParentAuthInfoWhereInput;
  AND?:
    | ParentAuthInfoSubscriptionWhereInput[]
    | ParentAuthInfoSubscriptionWhereInput;
  OR?:
    | ParentAuthInfoSubscriptionWhereInput[]
    | ParentAuthInfoSubscriptionWhereInput;
  NOT?:
    | ParentAuthInfoSubscriptionWhereInput[]
    | ParentAuthInfoSubscriptionWhereInput;
}

export interface ShortTermSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ShortTermWhereInput;
  AND?: ShortTermSubscriptionWhereInput[] | ShortTermSubscriptionWhereInput;
  OR?: ShortTermSubscriptionWhereInput[] | ShortTermSubscriptionWhereInput;
  NOT?: ShortTermSubscriptionWhereInput[] | ShortTermSubscriptionWhereInput;
}

export interface StudentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StudentWhereInput;
  AND?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
  OR?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
  NOT?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
}

export interface StudentAuthInfoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StudentAuthInfoWhereInput;
  AND?:
    | StudentAuthInfoSubscriptionWhereInput[]
    | StudentAuthInfoSubscriptionWhereInput;
  OR?:
    | StudentAuthInfoSubscriptionWhereInput[]
    | StudentAuthInfoSubscriptionWhereInput;
  NOT?:
    | StudentAuthInfoSubscriptionWhereInput[]
    | StudentAuthInfoSubscriptionWhereInput;
}

export interface StudentDetailSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StudentDetailWhereInput;
  AND?:
    | StudentDetailSubscriptionWhereInput[]
    | StudentDetailSubscriptionWhereInput;
  OR?:
    | StudentDetailSubscriptionWhereInput[]
    | StudentDetailSubscriptionWhereInput;
  NOT?:
    | StudentDetailSubscriptionWhereInput[]
    | StudentDetailSubscriptionWhereInput;
}

export interface SubjectSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SubjectWhereInput;
  AND?: SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput;
  OR?: SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput;
  NOT?: SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput;
}

export interface TryOrderSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TryOrderWhereInput;
  AND?: TryOrderSubscriptionWhereInput[] | TryOrderSubscriptionWhereInput;
  OR?: TryOrderSubscriptionWhereInput[] | TryOrderSubscriptionWhereInput;
  NOT?: TryOrderSubscriptionWhereInput[] | TryOrderSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface emerContactSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: emerContactWhereInput;
  AND?: emerContactSubscriptionWhereInput[] | emerContactSubscriptionWhereInput;
  OR?: emerContactSubscriptionWhereInput[] | emerContactSubscriptionWhereInput;
  NOT?: emerContactSubscriptionWhereInput[] | emerContactSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Admin {
  id: ID_Output;
  UnionID: String;
  name: String;
  phone: String;
  email: String;
}

export interface AdminPromise extends Promise<Admin>, Fragmentable {
  id: () => Promise<ID_Output>;
  UnionID: () => Promise<String>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  email: () => Promise<String>;
}

export interface AdminSubscription
  extends Promise<AsyncIterator<Admin>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  UnionID: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface AdminConnection {
  pageInfo: PageInfo;
  edges: AdminEdge[];
}

export interface AdminConnectionPromise
  extends Promise<AdminConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AdminEdge>>() => T;
  aggregate: <T = AggregateAdminPromise>() => T;
}

export interface AdminConnectionSubscription
  extends Promise<AsyncIterator<AdminConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AdminEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAdminSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AdminEdge {
  node: Admin;
  cursor: String;
}

export interface AdminEdgePromise extends Promise<AdminEdge>, Fragmentable {
  node: <T = AdminPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AdminEdgeSubscription
  extends Promise<AsyncIterator<AdminEdge>>,
    Fragmentable {
  node: <T = AdminSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAdmin {
  count: Int;
}

export interface AggregateAdminPromise
  extends Promise<AggregateAdmin>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAdminSubscription
  extends Promise<AsyncIterator<AggregateAdmin>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AvalibelTime {
  day: Day;
  detail: DetailTime;
}

export interface AvalibelTimePromise
  extends Promise<AvalibelTime>,
    Fragmentable {
  day: () => Promise<Day>;
  detail: () => Promise<DetailTime>;
}

export interface AvalibelTimeSubscription
  extends Promise<AsyncIterator<AvalibelTime>>,
    Fragmentable {
  day: () => Promise<AsyncIterator<Day>>;
  detail: () => Promise<AsyncIterator<DetailTime>>;
}

export interface AvalibelTimeConnection {
  pageInfo: PageInfo;
  edges: AvalibelTimeEdge[];
}

export interface AvalibelTimeConnectionPromise
  extends Promise<AvalibelTimeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AvalibelTimeEdge>>() => T;
  aggregate: <T = AggregateAvalibelTimePromise>() => T;
}

export interface AvalibelTimeConnectionSubscription
  extends Promise<AsyncIterator<AvalibelTimeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AvalibelTimeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAvalibelTimeSubscription>() => T;
}

export interface AvalibelTimeEdge {
  node: AvalibelTime;
  cursor: String;
}

export interface AvalibelTimeEdgePromise
  extends Promise<AvalibelTimeEdge>,
    Fragmentable {
  node: <T = AvalibelTimePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AvalibelTimeEdgeSubscription
  extends Promise<AsyncIterator<AvalibelTimeEdge>>,
    Fragmentable {
  node: <T = AvalibelTimeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAvalibelTime {
  count: Int;
}

export interface AggregateAvalibelTimePromise
  extends Promise<AggregateAvalibelTime>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAvalibelTimeSubscription
  extends Promise<AsyncIterator<AggregateAvalibelTime>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BasicTermInfo {
  id: ID_Output;
  Level: Level;
  subjects: SubjectName[];
  pay?: Int;
  childGender: Gender;
  teacherGender: SelectGender;
  teacherReuqire?: String;
  childStatus?: String;
}

export interface BasicTermInfoPromise
  extends Promise<BasicTermInfo>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  Level: () => Promise<Level>;
  subjects: () => Promise<SubjectName[]>;
  pay: () => Promise<Int>;
  childGender: () => Promise<Gender>;
  teacherGender: () => Promise<SelectGender>;
  teacherReuqire: () => Promise<String>;
  childStatus: () => Promise<String>;
  longTerm: <T = LongTermPromise>() => T;
  shortTerm: <T = ShortTermPromise>() => T;
}

export interface BasicTermInfoSubscription
  extends Promise<AsyncIterator<BasicTermInfo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  Level: () => Promise<AsyncIterator<Level>>;
  subjects: () => Promise<AsyncIterator<SubjectName[]>>;
  pay: () => Promise<AsyncIterator<Int>>;
  childGender: () => Promise<AsyncIterator<Gender>>;
  teacherGender: () => Promise<AsyncIterator<SelectGender>>;
  teacherReuqire: () => Promise<AsyncIterator<String>>;
  childStatus: () => Promise<AsyncIterator<String>>;
  longTerm: <T = LongTermSubscription>() => T;
  shortTerm: <T = ShortTermSubscription>() => T;
}

export interface LongTerm {
  id: ID_Output;
  lessonTime: Int;
  days: Int;
}

export interface LongTermPromise extends Promise<LongTerm>, Fragmentable {
  id: () => Promise<ID_Output>;
  lessonTime: () => Promise<Int>;
  days: () => Promise<Int>;
  timeList: <T = FragmentableArray<AvalibelTime>>(args?: {
    where?: AvalibelTimeWhereInput;
    orderBy?: AvalibelTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LongTermSubscription
  extends Promise<AsyncIterator<LongTerm>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lessonTime: () => Promise<AsyncIterator<Int>>;
  days: () => Promise<AsyncIterator<Int>>;
  timeList: <T = Promise<AsyncIterator<AvalibelTimeSubscription>>>(args?: {
    where?: AvalibelTimeWhereInput;
    orderBy?: AvalibelTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ShortTerm {
  shortTermId: ID_Output;
  timeList: DateTimeOutput[];
}

export interface ShortTermPromise extends Promise<ShortTerm>, Fragmentable {
  shortTermId: () => Promise<ID_Output>;
  timeList: () => Promise<DateTimeOutput[]>;
}

export interface ShortTermSubscription
  extends Promise<AsyncIterator<ShortTerm>>,
    Fragmentable {
  shortTermId: () => Promise<AsyncIterator<ID_Output>>;
  timeList: () => Promise<AsyncIterator<DateTimeOutput[]>>;
}

export interface BasicTermInfoConnection {
  pageInfo: PageInfo;
  edges: BasicTermInfoEdge[];
}

export interface BasicTermInfoConnectionPromise
  extends Promise<BasicTermInfoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BasicTermInfoEdge>>() => T;
  aggregate: <T = AggregateBasicTermInfoPromise>() => T;
}

export interface BasicTermInfoConnectionSubscription
  extends Promise<AsyncIterator<BasicTermInfoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BasicTermInfoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBasicTermInfoSubscription>() => T;
}

export interface BasicTermInfoEdge {
  node: BasicTermInfo;
  cursor: String;
}

export interface BasicTermInfoEdgePromise
  extends Promise<BasicTermInfoEdge>,
    Fragmentable {
  node: <T = BasicTermInfoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BasicTermInfoEdgeSubscription
  extends Promise<AsyncIterator<BasicTermInfoEdge>>,
    Fragmentable {
  node: <T = BasicTermInfoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBasicTermInfo {
  count: Int;
}

export interface AggregateBasicTermInfoPromise
  extends Promise<AggregateBasicTermInfo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBasicTermInfoSubscription
  extends Promise<AsyncIterator<AggregateBasicTermInfo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Invitation {
  id: ID_Output;
  invitor: Invitor;
  status: InvitationStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InvitationPromise extends Promise<Invitation>, Fragmentable {
  id: () => Promise<ID_Output>;
  student: <T = StudentPromise>() => T;
  parent: <T = ParentPromise>() => T;
  invitor: () => Promise<Invitor>;
  status: () => Promise<InvitationStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InvitationSubscription
  extends Promise<AsyncIterator<Invitation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  student: <T = StudentSubscription>() => T;
  parent: <T = ParentSubscription>() => T;
  invitor: () => Promise<AsyncIterator<Invitor>>;
  status: () => Promise<AsyncIterator<InvitationStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Student {
  id: ID_Output;
  UnionID: String;
  openid: String;
  phone: String;
  name: String;
  university: University;
  grades: String;
  email: String;
  Gender?: Gender;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  expectPay?: Int;
  authStatus: AuthStatus;
  publish: Boolean;
}

export interface StudentPromise extends Promise<Student>, Fragmentable {
  id: () => Promise<ID_Output>;
  UnionID: () => Promise<String>;
  openid: () => Promise<String>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  university: () => Promise<University>;
  grades: () => Promise<String>;
  email: () => Promise<String>;
  Gender: () => Promise<Gender>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  expectPay: () => Promise<Int>;
  authStatus: () => Promise<AuthStatus>;
  subjects: <T = FragmentableArray<Subject>>(args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  starList: <T = FragmentableArray<Parent>>(args?: {
    where?: ParentWhereInput;
    orderBy?: ParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  avalible: <T = FragmentableArray<AvalibelTime>>(args?: {
    where?: AvalibelTimeWhereInput;
    orderBy?: AvalibelTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  studentDetail: <T = StudentDetailPromise>() => T;
  invitations: <T = FragmentableArray<Invitation>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  publish: () => Promise<Boolean>;
}

export interface StudentSubscription
  extends Promise<AsyncIterator<Student>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  UnionID: () => Promise<AsyncIterator<String>>;
  openid: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  university: () => Promise<AsyncIterator<University>>;
  grades: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  Gender: () => Promise<AsyncIterator<Gender>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  expectPay: () => Promise<AsyncIterator<Int>>;
  authStatus: () => Promise<AsyncIterator<AuthStatus>>;
  subjects: <T = Promise<AsyncIterator<SubjectSubscription>>>(args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  starList: <T = Promise<AsyncIterator<ParentSubscription>>>(args?: {
    where?: ParentWhereInput;
    orderBy?: ParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  avalible: <T = Promise<AsyncIterator<AvalibelTimeSubscription>>>(args?: {
    where?: AvalibelTimeWhereInput;
    orderBy?: AvalibelTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  studentDetail: <T = StudentDetailSubscription>() => T;
  invitations: <T = Promise<AsyncIterator<InvitationSubscription>>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  publish: () => Promise<AsyncIterator<Boolean>>;
}

export interface Subject {
  name: SubjectName;
  level: Level[];
}

export interface SubjectPromise extends Promise<Subject>, Fragmentable {
  name: () => Promise<SubjectName>;
  level: () => Promise<Level[]>;
}

export interface SubjectSubscription
  extends Promise<AsyncIterator<Subject>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<SubjectName>>;
  level: () => Promise<AsyncIterator<Level[]>>;
}

export interface Parent {
  id: ID_Output;
  UnionID: String;
  phone: String;
  name: String;
  address: String;
  email: String;
  authStatus: AuthStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  publish: Boolean;
}

export interface ParentPromise extends Promise<Parent>, Fragmentable {
  id: () => Promise<ID_Output>;
  UnionID: () => Promise<String>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  email: () => Promise<String>;
  authStatus: () => Promise<AuthStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  starList: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invitations: <T = FragmentableArray<Invitation>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  publishTerm: <T = BasicTermInfoPromise>() => T;
  publish: () => Promise<Boolean>;
}

export interface ParentSubscription
  extends Promise<AsyncIterator<Parent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  UnionID: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  authStatus: () => Promise<AsyncIterator<AuthStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  starList: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invitations: <T = Promise<AsyncIterator<InvitationSubscription>>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  publishTerm: <T = BasicTermInfoSubscription>() => T;
  publish: () => Promise<AsyncIterator<Boolean>>;
}

export interface Order {
  id: ID_Output;
  status: OrderStatus;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  id: () => Promise<ID_Output>;
  stuednt: <T = StudentPromise>() => T;
  parent: <T = ParentPromise>() => T;
  status: () => Promise<OrderStatus>;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  stuednt: <T = StudentSubscription>() => T;
  parent: <T = ParentSubscription>() => T;
  status: () => Promise<AsyncIterator<OrderStatus>>;
}

export interface StudentDetail {
  selfIntro: String;
  grades: String;
  exprience: String;
  picture: String[];
}

export interface StudentDetailPromise
  extends Promise<StudentDetail>,
    Fragmentable {
  selfIntro: () => Promise<String>;
  grades: () => Promise<String>;
  exprience: () => Promise<String>;
  picture: () => Promise<String[]>;
}

export interface StudentDetailSubscription
  extends Promise<AsyncIterator<StudentDetail>>,
    Fragmentable {
  selfIntro: () => Promise<AsyncIterator<String>>;
  grades: () => Promise<AsyncIterator<String>>;
  exprience: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String[]>>;
}

export interface InvitationConnection {
  pageInfo: PageInfo;
  edges: InvitationEdge[];
}

export interface InvitationConnectionPromise
  extends Promise<InvitationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InvitationEdge>>() => T;
  aggregate: <T = AggregateInvitationPromise>() => T;
}

export interface InvitationConnectionSubscription
  extends Promise<AsyncIterator<InvitationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InvitationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInvitationSubscription>() => T;
}

export interface InvitationEdge {
  node: Invitation;
  cursor: String;
}

export interface InvitationEdgePromise
  extends Promise<InvitationEdge>,
    Fragmentable {
  node: <T = InvitationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InvitationEdgeSubscription
  extends Promise<AsyncIterator<InvitationEdge>>,
    Fragmentable {
  node: <T = InvitationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInvitation {
  count: Int;
}

export interface AggregateInvitationPromise
  extends Promise<AggregateInvitation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInvitationSubscription
  extends Promise<AsyncIterator<AggregateInvitation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LongTermConnection {
  pageInfo: PageInfo;
  edges: LongTermEdge[];
}

export interface LongTermConnectionPromise
  extends Promise<LongTermConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LongTermEdge>>() => T;
  aggregate: <T = AggregateLongTermPromise>() => T;
}

export interface LongTermConnectionSubscription
  extends Promise<AsyncIterator<LongTermConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LongTermEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLongTermSubscription>() => T;
}

export interface LongTermEdge {
  node: LongTerm;
  cursor: String;
}

export interface LongTermEdgePromise
  extends Promise<LongTermEdge>,
    Fragmentable {
  node: <T = LongTermPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LongTermEdgeSubscription
  extends Promise<AsyncIterator<LongTermEdge>>,
    Fragmentable {
  node: <T = LongTermSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLongTerm {
  count: Int;
}

export interface AggregateLongTermPromise
  extends Promise<AggregateLongTerm>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLongTermSubscription
  extends Promise<AsyncIterator<AggregateLongTerm>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ParentConnection {
  pageInfo: PageInfo;
  edges: ParentEdge[];
}

export interface ParentConnectionPromise
  extends Promise<ParentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ParentEdge>>() => T;
  aggregate: <T = AggregateParentPromise>() => T;
}

export interface ParentConnectionSubscription
  extends Promise<AsyncIterator<ParentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ParentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateParentSubscription>() => T;
}

export interface ParentEdge {
  node: Parent;
  cursor: String;
}

export interface ParentEdgePromise extends Promise<ParentEdge>, Fragmentable {
  node: <T = ParentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ParentEdgeSubscription
  extends Promise<AsyncIterator<ParentEdge>>,
    Fragmentable {
  node: <T = ParentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateParent {
  count: Int;
}

export interface AggregateParentPromise
  extends Promise<AggregateParent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateParentSubscription
  extends Promise<AsyncIterator<AggregateParent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ParentAuthInfo {
  id: ID_Output;
  UnionID: String;
  sourceUrl: String[];
  res: AuthStatus;
  info?: String;
}

export interface ParentAuthInfoPromise
  extends Promise<ParentAuthInfo>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parent: <T = ParentPromise>() => T;
  UnionID: () => Promise<String>;
  sourceUrl: () => Promise<String[]>;
  res: () => Promise<AuthStatus>;
  info: () => Promise<String>;
  Auth: <T = AdminPromise>() => T;
}

export interface ParentAuthInfoSubscription
  extends Promise<AsyncIterator<ParentAuthInfo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parent: <T = ParentSubscription>() => T;
  UnionID: () => Promise<AsyncIterator<String>>;
  sourceUrl: () => Promise<AsyncIterator<String[]>>;
  res: () => Promise<AsyncIterator<AuthStatus>>;
  info: () => Promise<AsyncIterator<String>>;
  Auth: <T = AdminSubscription>() => T;
}

export interface ParentAuthInfoConnection {
  pageInfo: PageInfo;
  edges: ParentAuthInfoEdge[];
}

export interface ParentAuthInfoConnectionPromise
  extends Promise<ParentAuthInfoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ParentAuthInfoEdge>>() => T;
  aggregate: <T = AggregateParentAuthInfoPromise>() => T;
}

export interface ParentAuthInfoConnectionSubscription
  extends Promise<AsyncIterator<ParentAuthInfoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ParentAuthInfoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateParentAuthInfoSubscription>() => T;
}

export interface ParentAuthInfoEdge {
  node: ParentAuthInfo;
  cursor: String;
}

export interface ParentAuthInfoEdgePromise
  extends Promise<ParentAuthInfoEdge>,
    Fragmentable {
  node: <T = ParentAuthInfoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ParentAuthInfoEdgeSubscription
  extends Promise<AsyncIterator<ParentAuthInfoEdge>>,
    Fragmentable {
  node: <T = ParentAuthInfoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateParentAuthInfo {
  count: Int;
}

export interface AggregateParentAuthInfoPromise
  extends Promise<AggregateParentAuthInfo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateParentAuthInfoSubscription
  extends Promise<AsyncIterator<AggregateParentAuthInfo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ShortTermConnection {
  pageInfo: PageInfo;
  edges: ShortTermEdge[];
}

export interface ShortTermConnectionPromise
  extends Promise<ShortTermConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShortTermEdge>>() => T;
  aggregate: <T = AggregateShortTermPromise>() => T;
}

export interface ShortTermConnectionSubscription
  extends Promise<AsyncIterator<ShortTermConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShortTermEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShortTermSubscription>() => T;
}

export interface ShortTermEdge {
  node: ShortTerm;
  cursor: String;
}

export interface ShortTermEdgePromise
  extends Promise<ShortTermEdge>,
    Fragmentable {
  node: <T = ShortTermPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShortTermEdgeSubscription
  extends Promise<AsyncIterator<ShortTermEdge>>,
    Fragmentable {
  node: <T = ShortTermSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateShortTerm {
  count: Int;
}

export interface AggregateShortTermPromise
  extends Promise<AggregateShortTerm>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShortTermSubscription
  extends Promise<AsyncIterator<AggregateShortTerm>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudentConnection {
  pageInfo: PageInfo;
  edges: StudentEdge[];
}

export interface StudentConnectionPromise
  extends Promise<StudentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudentEdge>>() => T;
  aggregate: <T = AggregateStudentPromise>() => T;
}

export interface StudentConnectionSubscription
  extends Promise<AsyncIterator<StudentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudentSubscription>() => T;
}

export interface StudentEdge {
  node: Student;
  cursor: String;
}

export interface StudentEdgePromise extends Promise<StudentEdge>, Fragmentable {
  node: <T = StudentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudentEdgeSubscription
  extends Promise<AsyncIterator<StudentEdge>>,
    Fragmentable {
  node: <T = StudentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudent {
  count: Int;
}

export interface AggregateStudentPromise
  extends Promise<AggregateStudent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudentSubscription
  extends Promise<AsyncIterator<AggregateStudent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudentAuthInfo {
  id: ID_Output;
  UnionID: String;
  sourceUrl: String[];
  res: AuthStatus;
  info?: String;
}

export interface StudentAuthInfoPromise
  extends Promise<StudentAuthInfo>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  UnionID: () => Promise<String>;
  student: <T = StudentPromise>() => T;
  sourceUrl: () => Promise<String[]>;
  res: () => Promise<AuthStatus>;
  info: () => Promise<String>;
  Auth: <T = AdminPromise>() => T;
}

export interface StudentAuthInfoSubscription
  extends Promise<AsyncIterator<StudentAuthInfo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  UnionID: () => Promise<AsyncIterator<String>>;
  student: <T = StudentSubscription>() => T;
  sourceUrl: () => Promise<AsyncIterator<String[]>>;
  res: () => Promise<AsyncIterator<AuthStatus>>;
  info: () => Promise<AsyncIterator<String>>;
  Auth: <T = AdminSubscription>() => T;
}

export interface StudentAuthInfoConnection {
  pageInfo: PageInfo;
  edges: StudentAuthInfoEdge[];
}

export interface StudentAuthInfoConnectionPromise
  extends Promise<StudentAuthInfoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudentAuthInfoEdge>>() => T;
  aggregate: <T = AggregateStudentAuthInfoPromise>() => T;
}

export interface StudentAuthInfoConnectionSubscription
  extends Promise<AsyncIterator<StudentAuthInfoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudentAuthInfoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudentAuthInfoSubscription>() => T;
}

export interface StudentAuthInfoEdge {
  node: StudentAuthInfo;
  cursor: String;
}

export interface StudentAuthInfoEdgePromise
  extends Promise<StudentAuthInfoEdge>,
    Fragmentable {
  node: <T = StudentAuthInfoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudentAuthInfoEdgeSubscription
  extends Promise<AsyncIterator<StudentAuthInfoEdge>>,
    Fragmentable {
  node: <T = StudentAuthInfoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudentAuthInfo {
  count: Int;
}

export interface AggregateStudentAuthInfoPromise
  extends Promise<AggregateStudentAuthInfo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudentAuthInfoSubscription
  extends Promise<AsyncIterator<AggregateStudentAuthInfo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudentDetailConnection {
  pageInfo: PageInfo;
  edges: StudentDetailEdge[];
}

export interface StudentDetailConnectionPromise
  extends Promise<StudentDetailConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudentDetailEdge>>() => T;
  aggregate: <T = AggregateStudentDetailPromise>() => T;
}

export interface StudentDetailConnectionSubscription
  extends Promise<AsyncIterator<StudentDetailConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudentDetailEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudentDetailSubscription>() => T;
}

export interface StudentDetailEdge {
  node: StudentDetail;
  cursor: String;
}

export interface StudentDetailEdgePromise
  extends Promise<StudentDetailEdge>,
    Fragmentable {
  node: <T = StudentDetailPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudentDetailEdgeSubscription
  extends Promise<AsyncIterator<StudentDetailEdge>>,
    Fragmentable {
  node: <T = StudentDetailSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudentDetail {
  count: Int;
}

export interface AggregateStudentDetailPromise
  extends Promise<AggregateStudentDetail>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudentDetailSubscription
  extends Promise<AsyncIterator<AggregateStudentDetail>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubjectConnection {
  pageInfo: PageInfo;
  edges: SubjectEdge[];
}

export interface SubjectConnectionPromise
  extends Promise<SubjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubjectEdge>>() => T;
  aggregate: <T = AggregateSubjectPromise>() => T;
}

export interface SubjectConnectionSubscription
  extends Promise<AsyncIterator<SubjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubjectSubscription>() => T;
}

export interface SubjectEdge {
  node: Subject;
  cursor: String;
}

export interface SubjectEdgePromise extends Promise<SubjectEdge>, Fragmentable {
  node: <T = SubjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubjectEdgeSubscription
  extends Promise<AsyncIterator<SubjectEdge>>,
    Fragmentable {
  node: <T = SubjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubject {
  count: Int;
}

export interface AggregateSubjectPromise
  extends Promise<AggregateSubject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubjectSubscription
  extends Promise<AsyncIterator<AggregateSubject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TryOrder {
  id: ID_Output;
  address: String;
  startTime?: DateTimeOutput;
  endTime?: DateTimeOutput;
  phone?: String;
  otherInfo?: String;
  status: tryOrderStatus;
  rejectInfo?: String;
}

export interface TryOrderPromise extends Promise<TryOrder>, Fragmentable {
  id: () => Promise<ID_Output>;
  student: <T = StudentPromise>() => T;
  parent: <T = ParentPromise>() => T;
  address: () => Promise<String>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  phone: () => Promise<String>;
  otherInfo: () => Promise<String>;
  emerContact: <T = FragmentableArray<emerContact>>(args?: {
    where?: emerContactWhereInput;
    orderBy?: emerContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<tryOrderStatus>;
  rejectInfo: () => Promise<String>;
}

export interface TryOrderSubscription
  extends Promise<AsyncIterator<TryOrder>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  student: <T = StudentSubscription>() => T;
  parent: <T = ParentSubscription>() => T;
  address: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  phone: () => Promise<AsyncIterator<String>>;
  otherInfo: () => Promise<AsyncIterator<String>>;
  emerContact: <T = Promise<AsyncIterator<emerContactSubscription>>>(args?: {
    where?: emerContactWhereInput;
    orderBy?: emerContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: () => Promise<AsyncIterator<tryOrderStatus>>;
  rejectInfo: () => Promise<AsyncIterator<String>>;
}

export interface emerContact {
  name: String;
  phone: String;
  relation: String;
}

export interface emerContactPromise extends Promise<emerContact>, Fragmentable {
  name: () => Promise<String>;
  phone: () => Promise<String>;
  relation: () => Promise<String>;
}

export interface emerContactSubscription
  extends Promise<AsyncIterator<emerContact>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  relation: () => Promise<AsyncIterator<String>>;
}

export interface TryOrderConnection {
  pageInfo: PageInfo;
  edges: TryOrderEdge[];
}

export interface TryOrderConnectionPromise
  extends Promise<TryOrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TryOrderEdge>>() => T;
  aggregate: <T = AggregateTryOrderPromise>() => T;
}

export interface TryOrderConnectionSubscription
  extends Promise<AsyncIterator<TryOrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TryOrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTryOrderSubscription>() => T;
}

export interface TryOrderEdge {
  node: TryOrder;
  cursor: String;
}

export interface TryOrderEdgePromise
  extends Promise<TryOrderEdge>,
    Fragmentable {
  node: <T = TryOrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TryOrderEdgeSubscription
  extends Promise<AsyncIterator<TryOrderEdge>>,
    Fragmentable {
  node: <T = TryOrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTryOrder {
  count: Int;
}

export interface AggregateTryOrderPromise
  extends Promise<AggregateTryOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTryOrderSubscription
  extends Promise<AsyncIterator<AggregateTryOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  UnionID: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  UnionID: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  UnionID: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface emerContactConnection {
  pageInfo: PageInfo;
  edges: emerContactEdge[];
}

export interface emerContactConnectionPromise
  extends Promise<emerContactConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<emerContactEdge>>() => T;
  aggregate: <T = AggregateemerContactPromise>() => T;
}

export interface emerContactConnectionSubscription
  extends Promise<AsyncIterator<emerContactConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<emerContactEdgeSubscription>>>() => T;
  aggregate: <T = AggregateemerContactSubscription>() => T;
}

export interface emerContactEdge {
  node: emerContact;
  cursor: String;
}

export interface emerContactEdgePromise
  extends Promise<emerContactEdge>,
    Fragmentable {
  node: <T = emerContactPromise>() => T;
  cursor: () => Promise<String>;
}

export interface emerContactEdgeSubscription
  extends Promise<AsyncIterator<emerContactEdge>>,
    Fragmentable {
  node: <T = emerContactSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateemerContact {
  count: Int;
}

export interface AggregateemerContactPromise
  extends Promise<AggregateemerContact>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateemerContactSubscription
  extends Promise<AsyncIterator<AggregateemerContact>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AdminSubscriptionPayload {
  mutation: MutationType;
  node: Admin;
  updatedFields: String[];
  previousValues: AdminPreviousValues;
}

export interface AdminSubscriptionPayloadPromise
  extends Promise<AdminSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AdminPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AdminPreviousValuesPromise>() => T;
}

export interface AdminSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AdminSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AdminSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AdminPreviousValuesSubscription>() => T;
}

export interface AdminPreviousValues {
  id: ID_Output;
  UnionID: String;
  name: String;
  phone: String;
  email: String;
}

export interface AdminPreviousValuesPromise
  extends Promise<AdminPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  UnionID: () => Promise<String>;
  name: () => Promise<String>;
  phone: () => Promise<String>;
  email: () => Promise<String>;
}

export interface AdminPreviousValuesSubscription
  extends Promise<AsyncIterator<AdminPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  UnionID: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface AvalibelTimeSubscriptionPayload {
  mutation: MutationType;
  node: AvalibelTime;
  updatedFields: String[];
  previousValues: AvalibelTimePreviousValues;
}

export interface AvalibelTimeSubscriptionPayloadPromise
  extends Promise<AvalibelTimeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AvalibelTimePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AvalibelTimePreviousValuesPromise>() => T;
}

export interface AvalibelTimeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AvalibelTimeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AvalibelTimeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AvalibelTimePreviousValuesSubscription>() => T;
}

export interface AvalibelTimePreviousValues {
  day: Day;
  detail: DetailTime;
}

export interface AvalibelTimePreviousValuesPromise
  extends Promise<AvalibelTimePreviousValues>,
    Fragmentable {
  day: () => Promise<Day>;
  detail: () => Promise<DetailTime>;
}

export interface AvalibelTimePreviousValuesSubscription
  extends Promise<AsyncIterator<AvalibelTimePreviousValues>>,
    Fragmentable {
  day: () => Promise<AsyncIterator<Day>>;
  detail: () => Promise<AsyncIterator<DetailTime>>;
}

export interface BasicTermInfoSubscriptionPayload {
  mutation: MutationType;
  node: BasicTermInfo;
  updatedFields: String[];
  previousValues: BasicTermInfoPreviousValues;
}

export interface BasicTermInfoSubscriptionPayloadPromise
  extends Promise<BasicTermInfoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BasicTermInfoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BasicTermInfoPreviousValuesPromise>() => T;
}

export interface BasicTermInfoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BasicTermInfoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BasicTermInfoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BasicTermInfoPreviousValuesSubscription>() => T;
}

export interface BasicTermInfoPreviousValues {
  id: ID_Output;
  Level: Level;
  subjects: SubjectName[];
  pay?: Int;
  childGender: Gender;
  teacherGender: SelectGender;
  teacherReuqire?: String;
  childStatus?: String;
}

export interface BasicTermInfoPreviousValuesPromise
  extends Promise<BasicTermInfoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  Level: () => Promise<Level>;
  subjects: () => Promise<SubjectName[]>;
  pay: () => Promise<Int>;
  childGender: () => Promise<Gender>;
  teacherGender: () => Promise<SelectGender>;
  teacherReuqire: () => Promise<String>;
  childStatus: () => Promise<String>;
}

export interface BasicTermInfoPreviousValuesSubscription
  extends Promise<AsyncIterator<BasicTermInfoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  Level: () => Promise<AsyncIterator<Level>>;
  subjects: () => Promise<AsyncIterator<SubjectName[]>>;
  pay: () => Promise<AsyncIterator<Int>>;
  childGender: () => Promise<AsyncIterator<Gender>>;
  teacherGender: () => Promise<AsyncIterator<SelectGender>>;
  teacherReuqire: () => Promise<AsyncIterator<String>>;
  childStatus: () => Promise<AsyncIterator<String>>;
}

export interface InvitationSubscriptionPayload {
  mutation: MutationType;
  node: Invitation;
  updatedFields: String[];
  previousValues: InvitationPreviousValues;
}

export interface InvitationSubscriptionPayloadPromise
  extends Promise<InvitationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InvitationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InvitationPreviousValuesPromise>() => T;
}

export interface InvitationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InvitationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InvitationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InvitationPreviousValuesSubscription>() => T;
}

export interface InvitationPreviousValues {
  id: ID_Output;
  invitor: Invitor;
  status: InvitationStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InvitationPreviousValuesPromise
  extends Promise<InvitationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  invitor: () => Promise<Invitor>;
  status: () => Promise<InvitationStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InvitationPreviousValuesSubscription
  extends Promise<AsyncIterator<InvitationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  invitor: () => Promise<AsyncIterator<Invitor>>;
  status: () => Promise<AsyncIterator<InvitationStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface LongTermSubscriptionPayload {
  mutation: MutationType;
  node: LongTerm;
  updatedFields: String[];
  previousValues: LongTermPreviousValues;
}

export interface LongTermSubscriptionPayloadPromise
  extends Promise<LongTermSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LongTermPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LongTermPreviousValuesPromise>() => T;
}

export interface LongTermSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LongTermSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LongTermSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LongTermPreviousValuesSubscription>() => T;
}

export interface LongTermPreviousValues {
  id: ID_Output;
  lessonTime: Int;
  days: Int;
}

export interface LongTermPreviousValuesPromise
  extends Promise<LongTermPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  lessonTime: () => Promise<Int>;
  days: () => Promise<Int>;
}

export interface LongTermPreviousValuesSubscription
  extends Promise<AsyncIterator<LongTermPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lessonTime: () => Promise<AsyncIterator<Int>>;
  days: () => Promise<AsyncIterator<Int>>;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface OrderPreviousValues {
  id: ID_Output;
  status: OrderStatus;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<OrderStatus>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<OrderStatus>>;
}

export interface ParentSubscriptionPayload {
  mutation: MutationType;
  node: Parent;
  updatedFields: String[];
  previousValues: ParentPreviousValues;
}

export interface ParentSubscriptionPayloadPromise
  extends Promise<ParentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ParentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ParentPreviousValuesPromise>() => T;
}

export interface ParentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ParentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ParentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ParentPreviousValuesSubscription>() => T;
}

export interface ParentPreviousValues {
  id: ID_Output;
  UnionID: String;
  phone: String;
  name: String;
  address: String;
  email: String;
  authStatus: AuthStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  publish: Boolean;
}

export interface ParentPreviousValuesPromise
  extends Promise<ParentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  UnionID: () => Promise<String>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  email: () => Promise<String>;
  authStatus: () => Promise<AuthStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  publish: () => Promise<Boolean>;
}

export interface ParentPreviousValuesSubscription
  extends Promise<AsyncIterator<ParentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  UnionID: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  authStatus: () => Promise<AsyncIterator<AuthStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  publish: () => Promise<AsyncIterator<Boolean>>;
}

export interface ParentAuthInfoSubscriptionPayload {
  mutation: MutationType;
  node: ParentAuthInfo;
  updatedFields: String[];
  previousValues: ParentAuthInfoPreviousValues;
}

export interface ParentAuthInfoSubscriptionPayloadPromise
  extends Promise<ParentAuthInfoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ParentAuthInfoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ParentAuthInfoPreviousValuesPromise>() => T;
}

export interface ParentAuthInfoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ParentAuthInfoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ParentAuthInfoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ParentAuthInfoPreviousValuesSubscription>() => T;
}

export interface ParentAuthInfoPreviousValues {
  id: ID_Output;
  UnionID: String;
  sourceUrl: String[];
  res: AuthStatus;
  info?: String;
}

export interface ParentAuthInfoPreviousValuesPromise
  extends Promise<ParentAuthInfoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  UnionID: () => Promise<String>;
  sourceUrl: () => Promise<String[]>;
  res: () => Promise<AuthStatus>;
  info: () => Promise<String>;
}

export interface ParentAuthInfoPreviousValuesSubscription
  extends Promise<AsyncIterator<ParentAuthInfoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  UnionID: () => Promise<AsyncIterator<String>>;
  sourceUrl: () => Promise<AsyncIterator<String[]>>;
  res: () => Promise<AsyncIterator<AuthStatus>>;
  info: () => Promise<AsyncIterator<String>>;
}

export interface ShortTermSubscriptionPayload {
  mutation: MutationType;
  node: ShortTerm;
  updatedFields: String[];
  previousValues: ShortTermPreviousValues;
}

export interface ShortTermSubscriptionPayloadPromise
  extends Promise<ShortTermSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShortTermPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShortTermPreviousValuesPromise>() => T;
}

export interface ShortTermSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShortTermSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShortTermSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShortTermPreviousValuesSubscription>() => T;
}

export interface ShortTermPreviousValues {
  shortTermId: ID_Output;
  timeList: DateTimeOutput[];
}

export interface ShortTermPreviousValuesPromise
  extends Promise<ShortTermPreviousValues>,
    Fragmentable {
  shortTermId: () => Promise<ID_Output>;
  timeList: () => Promise<DateTimeOutput[]>;
}

export interface ShortTermPreviousValuesSubscription
  extends Promise<AsyncIterator<ShortTermPreviousValues>>,
    Fragmentable {
  shortTermId: () => Promise<AsyncIterator<ID_Output>>;
  timeList: () => Promise<AsyncIterator<DateTimeOutput[]>>;
}

export interface StudentSubscriptionPayload {
  mutation: MutationType;
  node: Student;
  updatedFields: String[];
  previousValues: StudentPreviousValues;
}

export interface StudentSubscriptionPayloadPromise
  extends Promise<StudentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudentPreviousValuesPromise>() => T;
}

export interface StudentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudentPreviousValuesSubscription>() => T;
}

export interface StudentPreviousValues {
  id: ID_Output;
  UnionID: String;
  openid: String;
  phone: String;
  name: String;
  university: University;
  grades: String;
  email: String;
  Gender?: Gender;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  expectPay?: Int;
  authStatus: AuthStatus;
  publish: Boolean;
}

export interface StudentPreviousValuesPromise
  extends Promise<StudentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  UnionID: () => Promise<String>;
  openid: () => Promise<String>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  university: () => Promise<University>;
  grades: () => Promise<String>;
  email: () => Promise<String>;
  Gender: () => Promise<Gender>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  expectPay: () => Promise<Int>;
  authStatus: () => Promise<AuthStatus>;
  publish: () => Promise<Boolean>;
}

export interface StudentPreviousValuesSubscription
  extends Promise<AsyncIterator<StudentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  UnionID: () => Promise<AsyncIterator<String>>;
  openid: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  university: () => Promise<AsyncIterator<University>>;
  grades: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  Gender: () => Promise<AsyncIterator<Gender>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  expectPay: () => Promise<AsyncIterator<Int>>;
  authStatus: () => Promise<AsyncIterator<AuthStatus>>;
  publish: () => Promise<AsyncIterator<Boolean>>;
}

export interface StudentAuthInfoSubscriptionPayload {
  mutation: MutationType;
  node: StudentAuthInfo;
  updatedFields: String[];
  previousValues: StudentAuthInfoPreviousValues;
}

export interface StudentAuthInfoSubscriptionPayloadPromise
  extends Promise<StudentAuthInfoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudentAuthInfoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudentAuthInfoPreviousValuesPromise>() => T;
}

export interface StudentAuthInfoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudentAuthInfoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudentAuthInfoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudentAuthInfoPreviousValuesSubscription>() => T;
}

export interface StudentAuthInfoPreviousValues {
  id: ID_Output;
  UnionID: String;
  sourceUrl: String[];
  res: AuthStatus;
  info?: String;
}

export interface StudentAuthInfoPreviousValuesPromise
  extends Promise<StudentAuthInfoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  UnionID: () => Promise<String>;
  sourceUrl: () => Promise<String[]>;
  res: () => Promise<AuthStatus>;
  info: () => Promise<String>;
}

export interface StudentAuthInfoPreviousValuesSubscription
  extends Promise<AsyncIterator<StudentAuthInfoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  UnionID: () => Promise<AsyncIterator<String>>;
  sourceUrl: () => Promise<AsyncIterator<String[]>>;
  res: () => Promise<AsyncIterator<AuthStatus>>;
  info: () => Promise<AsyncIterator<String>>;
}

export interface StudentDetailSubscriptionPayload {
  mutation: MutationType;
  node: StudentDetail;
  updatedFields: String[];
  previousValues: StudentDetailPreviousValues;
}

export interface StudentDetailSubscriptionPayloadPromise
  extends Promise<StudentDetailSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudentDetailPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudentDetailPreviousValuesPromise>() => T;
}

export interface StudentDetailSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudentDetailSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudentDetailSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudentDetailPreviousValuesSubscription>() => T;
}

export interface StudentDetailPreviousValues {
  selfIntro: String;
  grades: String;
  exprience: String;
  picture: String[];
}

export interface StudentDetailPreviousValuesPromise
  extends Promise<StudentDetailPreviousValues>,
    Fragmentable {
  selfIntro: () => Promise<String>;
  grades: () => Promise<String>;
  exprience: () => Promise<String>;
  picture: () => Promise<String[]>;
}

export interface StudentDetailPreviousValuesSubscription
  extends Promise<AsyncIterator<StudentDetailPreviousValues>>,
    Fragmentable {
  selfIntro: () => Promise<AsyncIterator<String>>;
  grades: () => Promise<AsyncIterator<String>>;
  exprience: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String[]>>;
}

export interface SubjectSubscriptionPayload {
  mutation: MutationType;
  node: Subject;
  updatedFields: String[];
  previousValues: SubjectPreviousValues;
}

export interface SubjectSubscriptionPayloadPromise
  extends Promise<SubjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubjectPreviousValuesPromise>() => T;
}

export interface SubjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubjectPreviousValuesSubscription>() => T;
}

export interface SubjectPreviousValues {
  name: SubjectName;
  level: Level[];
}

export interface SubjectPreviousValuesPromise
  extends Promise<SubjectPreviousValues>,
    Fragmentable {
  name: () => Promise<SubjectName>;
  level: () => Promise<Level[]>;
}

export interface SubjectPreviousValuesSubscription
  extends Promise<AsyncIterator<SubjectPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<SubjectName>>;
  level: () => Promise<AsyncIterator<Level[]>>;
}

export interface TryOrderSubscriptionPayload {
  mutation: MutationType;
  node: TryOrder;
  updatedFields: String[];
  previousValues: TryOrderPreviousValues;
}

export interface TryOrderSubscriptionPayloadPromise
  extends Promise<TryOrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TryOrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TryOrderPreviousValuesPromise>() => T;
}

export interface TryOrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TryOrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TryOrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TryOrderPreviousValuesSubscription>() => T;
}

export interface TryOrderPreviousValues {
  id: ID_Output;
  address: String;
  startTime?: DateTimeOutput;
  endTime?: DateTimeOutput;
  phone?: String;
  otherInfo?: String;
  status: tryOrderStatus;
  rejectInfo?: String;
}

export interface TryOrderPreviousValuesPromise
  extends Promise<TryOrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  address: () => Promise<String>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  phone: () => Promise<String>;
  otherInfo: () => Promise<String>;
  status: () => Promise<tryOrderStatus>;
  rejectInfo: () => Promise<String>;
}

export interface TryOrderPreviousValuesSubscription
  extends Promise<AsyncIterator<TryOrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  address: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  phone: () => Promise<AsyncIterator<String>>;
  otherInfo: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<tryOrderStatus>>;
  rejectInfo: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  UnionID: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  UnionID: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  UnionID: () => Promise<AsyncIterator<String>>;
}

export interface emerContactSubscriptionPayload {
  mutation: MutationType;
  node: emerContact;
  updatedFields: String[];
  previousValues: emerContactPreviousValues;
}

export interface emerContactSubscriptionPayloadPromise
  extends Promise<emerContactSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = emerContactPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = emerContactPreviousValuesPromise>() => T;
}

export interface emerContactSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<emerContactSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = emerContactSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = emerContactPreviousValuesSubscription>() => T;
}

export interface emerContactPreviousValues {
  name: String;
  phone: String;
  relation: String;
}

export interface emerContactPreviousValuesPromise
  extends Promise<emerContactPreviousValues>,
    Fragmentable {
  name: () => Promise<String>;
  phone: () => Promise<String>;
  relation: () => Promise<String>;
}

export interface emerContactPreviousValuesSubscription
  extends Promise<AsyncIterator<emerContactPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  relation: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Admin",
    embedded: false
  },
  {
    name: "AuthStatus",
    embedded: false
  },
  {
    name: "AvalibelTime",
    embedded: false
  },
  {
    name: "BasicTermInfo",
    embedded: false
  },
  {
    name: "Day",
    embedded: false
  },
  {
    name: "DetailTime",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "Invitation",
    embedded: false
  },
  {
    name: "InvitationStatus",
    embedded: false
  },
  {
    name: "Invitor",
    embedded: false
  },
  {
    name: "Level",
    embedded: false
  },
  {
    name: "LongTerm",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "OrderStatus",
    embedded: false
  },
  {
    name: "Parent",
    embedded: false
  },
  {
    name: "ParentAuthInfo",
    embedded: false
  },
  {
    name: "SelectGender",
    embedded: false
  },
  {
    name: "ShortTerm",
    embedded: false
  },
  {
    name: "Student",
    embedded: false
  },
  {
    name: "StudentAuthInfo",
    embedded: false
  },
  {
    name: "StudentDetail",
    embedded: false
  },
  {
    name: "Subject",
    embedded: false
  },
  {
    name: "SubjectName",
    embedded: false
  },
  {
    name: "TryOrder",
    embedded: false
  },
  {
    name: "University",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "emerContact",
    embedded: false
  },
  {
    name: "tryOrderStatus",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
