// Code generated by Prisma (prisma@1.24.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  avalibelTime: (where?: AvalibelTimeWhereInput) => Promise<boolean>;
  basicTermInfo: (where?: BasicTermInfoWhereInput) => Promise<boolean>;
  invitation: (where?: InvitationWhereInput) => Promise<boolean>;
  longTerm: (where?: LongTermWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  parent: (where?: ParentWhereInput) => Promise<boolean>;
  shortTerm: (where?: ShortTermWhereInput) => Promise<boolean>;
  student: (where?: StudentWhereInput) => Promise<boolean>;
  studentDetail: (where?: StudentDetailWhereInput) => Promise<boolean>;
  subject: (where?: SubjectWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  avalibelTimes: (args?: {
    where?: AvalibelTimeWhereInput;
    orderBy?: AvalibelTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AvalibelTime>;
  avalibelTimesConnection: (args?: {
    where?: AvalibelTimeWhereInput;
    orderBy?: AvalibelTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AvalibelTimeConnectionPromise;
  basicTermInfo: (where: BasicTermInfoWhereUniqueInput) => BasicTermInfoPromise;
  basicTermInfoes: (args?: {
    where?: BasicTermInfoWhereInput;
    orderBy?: BasicTermInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<BasicTermInfo>;
  basicTermInfoesConnection: (args?: {
    where?: BasicTermInfoWhereInput;
    orderBy?: BasicTermInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BasicTermInfoConnectionPromise;
  invitation: (where: InvitationWhereUniqueInput) => InvitationPromise;
  invitations: (args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Invitation>;
  invitationsConnection: (args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InvitationConnectionPromise;
  longTerm: (where: LongTermWhereUniqueInput) => LongTermPromise;
  longTerms: (args?: {
    where?: LongTermWhereInput;
    orderBy?: LongTermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LongTerm>;
  longTermsConnection: (args?: {
    where?: LongTermWhereInput;
    orderBy?: LongTermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LongTermConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderPromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  parent: (where: ParentWhereUniqueInput) => ParentPromise;
  parents: (args?: {
    where?: ParentWhereInput;
    orderBy?: ParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Parent>;
  parentsConnection: (args?: {
    where?: ParentWhereInput;
    orderBy?: ParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ParentConnectionPromise;
  shortTerm: (where: ShortTermWhereUniqueInput) => ShortTermPromise;
  shortTerms: (args?: {
    where?: ShortTermWhereInput;
    orderBy?: ShortTermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ShortTerm>;
  shortTermsConnection: (args?: {
    where?: ShortTermWhereInput;
    orderBy?: ShortTermOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ShortTermConnectionPromise;
  student: (where: StudentWhereUniqueInput) => StudentPromise;
  students: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Student>;
  studentsConnection: (args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudentConnectionPromise;
  studentDetails: (args?: {
    where?: StudentDetailWhereInput;
    orderBy?: StudentDetailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<StudentDetail>;
  studentDetailsConnection: (args?: {
    where?: StudentDetailWhereInput;
    orderBy?: StudentDetailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudentDetailConnectionPromise;
  subjects: (args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Subject>;
  subjectsConnection: (args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SubjectConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAvalibelTime: (data: AvalibelTimeCreateInput) => AvalibelTimePromise;
  updateManyAvalibelTimes: (args: {
    data: AvalibelTimeUpdateManyMutationInput;
    where?: AvalibelTimeWhereInput;
  }) => BatchPayloadPromise;
  deleteManyAvalibelTimes: (
    where?: AvalibelTimeWhereInput
  ) => BatchPayloadPromise;
  createBasicTermInfo: (data: BasicTermInfoCreateInput) => BasicTermInfoPromise;
  updateBasicTermInfo: (args: {
    data: BasicTermInfoUpdateInput;
    where: BasicTermInfoWhereUniqueInput;
  }) => BasicTermInfoPromise;
  updateManyBasicTermInfoes: (args: {
    data: BasicTermInfoUpdateManyMutationInput;
    where?: BasicTermInfoWhereInput;
  }) => BatchPayloadPromise;
  upsertBasicTermInfo: (args: {
    where: BasicTermInfoWhereUniqueInput;
    create: BasicTermInfoCreateInput;
    update: BasicTermInfoUpdateInput;
  }) => BasicTermInfoPromise;
  deleteBasicTermInfo: (
    where: BasicTermInfoWhereUniqueInput
  ) => BasicTermInfoPromise;
  deleteManyBasicTermInfoes: (
    where?: BasicTermInfoWhereInput
  ) => BatchPayloadPromise;
  createInvitation: (data: InvitationCreateInput) => InvitationPromise;
  updateInvitation: (args: {
    data: InvitationUpdateInput;
    where: InvitationWhereUniqueInput;
  }) => InvitationPromise;
  updateManyInvitations: (args: {
    data: InvitationUpdateManyMutationInput;
    where?: InvitationWhereInput;
  }) => BatchPayloadPromise;
  upsertInvitation: (args: {
    where: InvitationWhereUniqueInput;
    create: InvitationCreateInput;
    update: InvitationUpdateInput;
  }) => InvitationPromise;
  deleteInvitation: (where: InvitationWhereUniqueInput) => InvitationPromise;
  deleteManyInvitations: (where?: InvitationWhereInput) => BatchPayloadPromise;
  createLongTerm: (data: LongTermCreateInput) => LongTermPromise;
  updateLongTerm: (args: {
    data: LongTermUpdateInput;
    where: LongTermWhereUniqueInput;
  }) => LongTermPromise;
  updateManyLongTerms: (args: {
    data: LongTermUpdateManyMutationInput;
    where?: LongTermWhereInput;
  }) => BatchPayloadPromise;
  upsertLongTerm: (args: {
    where: LongTermWhereUniqueInput;
    create: LongTermCreateInput;
    update: LongTermUpdateInput;
  }) => LongTermPromise;
  deleteLongTerm: (where: LongTermWhereUniqueInput) => LongTermPromise;
  deleteManyLongTerms: (where?: LongTermWhereInput) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (args: {
    data: OrderUpdateInput;
    where: OrderWhereUniqueInput;
  }) => OrderPromise;
  updateManyOrders: (args: {
    data: OrderUpdateManyMutationInput;
    where?: OrderWhereInput;
  }) => BatchPayloadPromise;
  upsertOrder: (args: {
    where: OrderWhereUniqueInput;
    create: OrderCreateInput;
    update: OrderUpdateInput;
  }) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createParent: (data: ParentCreateInput) => ParentPromise;
  updateParent: (args: {
    data: ParentUpdateInput;
    where: ParentWhereUniqueInput;
  }) => ParentPromise;
  updateManyParents: (args: {
    data: ParentUpdateManyMutationInput;
    where?: ParentWhereInput;
  }) => BatchPayloadPromise;
  upsertParent: (args: {
    where: ParentWhereUniqueInput;
    create: ParentCreateInput;
    update: ParentUpdateInput;
  }) => ParentPromise;
  deleteParent: (where: ParentWhereUniqueInput) => ParentPromise;
  deleteManyParents: (where?: ParentWhereInput) => BatchPayloadPromise;
  createShortTerm: (data: ShortTermCreateInput) => ShortTermPromise;
  updateShortTerm: (args: {
    data: ShortTermUpdateInput;
    where: ShortTermWhereUniqueInput;
  }) => ShortTermPromise;
  updateManyShortTerms: (args: {
    data: ShortTermUpdateManyMutationInput;
    where?: ShortTermWhereInput;
  }) => BatchPayloadPromise;
  upsertShortTerm: (args: {
    where: ShortTermWhereUniqueInput;
    create: ShortTermCreateInput;
    update: ShortTermUpdateInput;
  }) => ShortTermPromise;
  deleteShortTerm: (where: ShortTermWhereUniqueInput) => ShortTermPromise;
  deleteManyShortTerms: (where?: ShortTermWhereInput) => BatchPayloadPromise;
  createStudent: (data: StudentCreateInput) => StudentPromise;
  updateStudent: (args: {
    data: StudentUpdateInput;
    where: StudentWhereUniqueInput;
  }) => StudentPromise;
  updateManyStudents: (args: {
    data: StudentUpdateManyMutationInput;
    where?: StudentWhereInput;
  }) => BatchPayloadPromise;
  upsertStudent: (args: {
    where: StudentWhereUniqueInput;
    create: StudentCreateInput;
    update: StudentUpdateInput;
  }) => StudentPromise;
  deleteStudent: (where: StudentWhereUniqueInput) => StudentPromise;
  deleteManyStudents: (where?: StudentWhereInput) => BatchPayloadPromise;
  createStudentDetail: (data: StudentDetailCreateInput) => StudentDetailPromise;
  updateManyStudentDetails: (args: {
    data: StudentDetailUpdateManyMutationInput;
    where?: StudentDetailWhereInput;
  }) => BatchPayloadPromise;
  deleteManyStudentDetails: (
    where?: StudentDetailWhereInput
  ) => BatchPayloadPromise;
  createSubject: (data: SubjectCreateInput) => SubjectPromise;
  updateManySubjects: (args: {
    data: SubjectUpdateManyMutationInput;
    where?: SubjectWhereInput;
  }) => BatchPayloadPromise;
  deleteManySubjects: (where?: SubjectWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  avalibelTime: (
    where?: AvalibelTimeSubscriptionWhereInput
  ) => AvalibelTimeSubscriptionPayloadSubscription;
  basicTermInfo: (
    where?: BasicTermInfoSubscriptionWhereInput
  ) => BasicTermInfoSubscriptionPayloadSubscription;
  invitation: (
    where?: InvitationSubscriptionWhereInput
  ) => InvitationSubscriptionPayloadSubscription;
  longTerm: (
    where?: LongTermSubscriptionWhereInput
  ) => LongTermSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  parent: (
    where?: ParentSubscriptionWhereInput
  ) => ParentSubscriptionPayloadSubscription;
  shortTerm: (
    where?: ShortTermSubscriptionWhereInput
  ) => ShortTermSubscriptionPayloadSubscription;
  student: (
    where?: StudentSubscriptionWhereInput
  ) => StudentSubscriptionPayloadSubscription;
  studentDetail: (
    where?: StudentDetailSubscriptionWhereInput
  ) => StudentDetailSubscriptionPayloadSubscription;
  subject: (
    where?: SubjectSubscriptionWhereInput
  ) => SubjectSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Day = "SUN" | "MON" | "TUE" | "WED" | "THU" | "FRI" | "SAT";

export type DetailTime = "MORN" | "NOON" | "AFTER";

export type AvalibelTimeOrderByInput =
  | "day_ASC"
  | "day_DESC"
  | "detail_ASC"
  | "detail_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SubjectName =
  | "CHINESE"
  | "MATH"
  | "ENGLISH"
  | "PHYSICS"
  | "CHEMSTRY"
  | "BIOLOGY"
  | "HISTORY"
  | "GEOGRAPHY"
  | "OTHER";

export type SubjectOrderByInput =
  | "name_ASC"
  | "name_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Level = "PRIMARY" | "MIDDLE" | "MIDDLEHIGH" | "OTHER";

export type Gender = "MALE" | "FEMALE";

export type SelectGender = "MALE" | "FEMALE" | "BOTH";

export type BasicTermInfoOrderByInput =
  | "termId_ASC"
  | "termId_DESC"
  | "pay_ASC"
  | "pay_DESC"
  | "childGender_ASC"
  | "childGender_DESC"
  | "TeacherGender_ASC"
  | "TeacherGender_DESC"
  | "teacherReuqire_ASC"
  | "teacherReuqire_DESC"
  | "childStatus_ASC"
  | "childStatus_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type University = "HUST" | "WHU";

export type AuthStatus = "UNCOMMITED" | "AUTHCOMMITED" | "AUTHED";

export type Invitor = "STUDENT" | "PARENT";

export type InvitationStatus = "REBACK" | "WAITING" | "AGREED" | "REJECTED";

export type OrderStatus = "PAIED" | "UNPAIED" | "FINISHED";

export type ParentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address_ASC"
  | "address_DESC"
  | "email_ASC"
  | "email_DESC"
  | "UnionID_ASC"
  | "UnionID_DESC"
  | "authstatus_ASC"
  | "authstatus_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StudentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "UnionID_ASC"
  | "UnionID_DESC"
  | "openid_ASC"
  | "openid_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "name_ASC"
  | "name_DESC"
  | "university_ASC"
  | "university_DESC"
  | "email_ASC"
  | "email_DESC"
  | "Gender_ASC"
  | "Gender_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "expectPay_ASC"
  | "expectPay_DESC"
  | "authstatus_ASC"
  | "authstatus_DESC";

export type InvitationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "invitor_ASC"
  | "invitor_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OrderOrderByInput =
  | "order_ASC"
  | "order_DESC"
  | "status_ASC"
  | "status_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LongTermOrderByInput =
  | "longTermId_ASC"
  | "longTermId_DESC"
  | "lessonTime_ASC"
  | "lessonTime_DESC"
  | "days_ASC"
  | "days_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ShortTermOrderByInput =
  | "shortTermId_ASC"
  | "shortTermId_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StudentDetailOrderByInput =
  | "selfIntro_ASC"
  | "selfIntro_DESC"
  | "grades_ASC"
  | "grades_DESC"
  | "exprience_ASC"
  | "exprience_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "UnionID_ASC"
  | "UnionID_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface AvalibelTimeWhereInput {
  day?: Day;
  day_not?: Day;
  day_in?: Day[] | Day;
  day_not_in?: Day[] | Day;
  detail?: DetailTime;
  detail_not?: DetailTime;
  detail_in?: DetailTime[] | DetailTime;
  detail_not_in?: DetailTime[] | DetailTime;
  AND?: AvalibelTimeWhereInput[] | AvalibelTimeWhereInput;
  OR?: AvalibelTimeWhereInput[] | AvalibelTimeWhereInput;
  NOT?: AvalibelTimeWhereInput[] | AvalibelTimeWhereInput;
}

export type BasicTermInfoWhereUniqueInput = AtLeastOne<{
  termId: ID_Input;
}>;

export interface SubjectWhereInput {
  name?: SubjectName;
  name_not?: SubjectName;
  name_in?: SubjectName[] | SubjectName;
  name_not_in?: SubjectName[] | SubjectName;
  AND?: SubjectWhereInput[] | SubjectWhereInput;
  OR?: SubjectWhereInput[] | SubjectWhereInput;
  NOT?: SubjectWhereInput[] | SubjectWhereInput;
}

export interface BasicTermInfoWhereInput {
  termId?: ID_Input;
  termId_not?: ID_Input;
  termId_in?: ID_Input[] | ID_Input;
  termId_not_in?: ID_Input[] | ID_Input;
  termId_lt?: ID_Input;
  termId_lte?: ID_Input;
  termId_gt?: ID_Input;
  termId_gte?: ID_Input;
  termId_contains?: ID_Input;
  termId_not_contains?: ID_Input;
  termId_starts_with?: ID_Input;
  termId_not_starts_with?: ID_Input;
  termId_ends_with?: ID_Input;
  termId_not_ends_with?: ID_Input;
  subjects_every?: SubjectWhereInput;
  subjects_some?: SubjectWhereInput;
  subjects_none?: SubjectWhereInput;
  pay?: Int;
  pay_not?: Int;
  pay_in?: Int[] | Int;
  pay_not_in?: Int[] | Int;
  pay_lt?: Int;
  pay_lte?: Int;
  pay_gt?: Int;
  pay_gte?: Int;
  childGender?: Gender;
  childGender_not?: Gender;
  childGender_in?: Gender[] | Gender;
  childGender_not_in?: Gender[] | Gender;
  TeacherGender?: SelectGender;
  TeacherGender_not?: SelectGender;
  TeacherGender_in?: SelectGender[] | SelectGender;
  TeacherGender_not_in?: SelectGender[] | SelectGender;
  teacherReuqire?: String;
  teacherReuqire_not?: String;
  teacherReuqire_in?: String[] | String;
  teacherReuqire_not_in?: String[] | String;
  teacherReuqire_lt?: String;
  teacherReuqire_lte?: String;
  teacherReuqire_gt?: String;
  teacherReuqire_gte?: String;
  teacherReuqire_contains?: String;
  teacherReuqire_not_contains?: String;
  teacherReuqire_starts_with?: String;
  teacherReuqire_not_starts_with?: String;
  teacherReuqire_ends_with?: String;
  teacherReuqire_not_ends_with?: String;
  childStatus?: String;
  childStatus_not?: String;
  childStatus_in?: String[] | String;
  childStatus_not_in?: String[] | String;
  childStatus_lt?: String;
  childStatus_lte?: String;
  childStatus_gt?: String;
  childStatus_gte?: String;
  childStatus_contains?: String;
  childStatus_not_contains?: String;
  childStatus_starts_with?: String;
  childStatus_not_starts_with?: String;
  childStatus_ends_with?: String;
  childStatus_not_ends_with?: String;
  longTerm?: LongTermWhereInput;
  shortTerm?: ShortTermWhereInput;
  AND?: BasicTermInfoWhereInput[] | BasicTermInfoWhereInput;
  OR?: BasicTermInfoWhereInput[] | BasicTermInfoWhereInput;
  NOT?: BasicTermInfoWhereInput[] | BasicTermInfoWhereInput;
}

export interface LongTermWhereInput {
  longTermId?: ID_Input;
  longTermId_not?: ID_Input;
  longTermId_in?: ID_Input[] | ID_Input;
  longTermId_not_in?: ID_Input[] | ID_Input;
  longTermId_lt?: ID_Input;
  longTermId_lte?: ID_Input;
  longTermId_gt?: ID_Input;
  longTermId_gte?: ID_Input;
  longTermId_contains?: ID_Input;
  longTermId_not_contains?: ID_Input;
  longTermId_starts_with?: ID_Input;
  longTermId_not_starts_with?: ID_Input;
  longTermId_ends_with?: ID_Input;
  longTermId_not_ends_with?: ID_Input;
  lessonTime?: Int;
  lessonTime_not?: Int;
  lessonTime_in?: Int[] | Int;
  lessonTime_not_in?: Int[] | Int;
  lessonTime_lt?: Int;
  lessonTime_lte?: Int;
  lessonTime_gt?: Int;
  lessonTime_gte?: Int;
  days?: Int;
  days_not?: Int;
  days_in?: Int[] | Int;
  days_not_in?: Int[] | Int;
  days_lt?: Int;
  days_lte?: Int;
  days_gt?: Int;
  days_gte?: Int;
  timeList_every?: AvalibelTimeWhereInput;
  timeList_some?: AvalibelTimeWhereInput;
  timeList_none?: AvalibelTimeWhereInput;
  AND?: LongTermWhereInput[] | LongTermWhereInput;
  OR?: LongTermWhereInput[] | LongTermWhereInput;
  NOT?: LongTermWhereInput[] | LongTermWhereInput;
}

export interface ShortTermWhereInput {
  shortTermId?: ID_Input;
  shortTermId_not?: ID_Input;
  shortTermId_in?: ID_Input[] | ID_Input;
  shortTermId_not_in?: ID_Input[] | ID_Input;
  shortTermId_lt?: ID_Input;
  shortTermId_lte?: ID_Input;
  shortTermId_gt?: ID_Input;
  shortTermId_gte?: ID_Input;
  shortTermId_contains?: ID_Input;
  shortTermId_not_contains?: ID_Input;
  shortTermId_starts_with?: ID_Input;
  shortTermId_not_starts_with?: ID_Input;
  shortTermId_ends_with?: ID_Input;
  shortTermId_not_ends_with?: ID_Input;
  AND?: ShortTermWhereInput[] | ShortTermWhereInput;
  OR?: ShortTermWhereInput[] | ShortTermWhereInput;
  NOT?: ShortTermWhereInput[] | ShortTermWhereInput;
}

export type InvitationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ParentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  UnionID?: String;
  UnionID_not?: String;
  UnionID_in?: String[] | String;
  UnionID_not_in?: String[] | String;
  UnionID_lt?: String;
  UnionID_lte?: String;
  UnionID_gt?: String;
  UnionID_gte?: String;
  UnionID_contains?: String;
  UnionID_not_contains?: String;
  UnionID_starts_with?: String;
  UnionID_not_starts_with?: String;
  UnionID_ends_with?: String;
  UnionID_not_ends_with?: String;
  authstatus?: AuthStatus;
  authstatus_not?: AuthStatus;
  authstatus_in?: AuthStatus[] | AuthStatus;
  authstatus_not_in?: AuthStatus[] | AuthStatus;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  starList_every?: StudentWhereInput;
  starList_some?: StudentWhereInput;
  starList_none?: StudentWhereInput;
  invitations_every?: InvitationWhereInput;
  invitations_some?: InvitationWhereInput;
  invitations_none?: InvitationWhereInput;
  order_every?: OrderWhereInput;
  order_some?: OrderWhereInput;
  order_none?: OrderWhereInput;
  publishTerm_every?: BasicTermInfoWhereInput;
  publishTerm_some?: BasicTermInfoWhereInput;
  publishTerm_none?: BasicTermInfoWhereInput;
  AND?: ParentWhereInput[] | ParentWhereInput;
  OR?: ParentWhereInput[] | ParentWhereInput;
  NOT?: ParentWhereInput[] | ParentWhereInput;
}

export interface StudentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  UnionID?: String;
  UnionID_not?: String;
  UnionID_in?: String[] | String;
  UnionID_not_in?: String[] | String;
  UnionID_lt?: String;
  UnionID_lte?: String;
  UnionID_gt?: String;
  UnionID_gte?: String;
  UnionID_contains?: String;
  UnionID_not_contains?: String;
  UnionID_starts_with?: String;
  UnionID_not_starts_with?: String;
  UnionID_ends_with?: String;
  UnionID_not_ends_with?: String;
  openid?: String;
  openid_not?: String;
  openid_in?: String[] | String;
  openid_not_in?: String[] | String;
  openid_lt?: String;
  openid_lte?: String;
  openid_gt?: String;
  openid_gte?: String;
  openid_contains?: String;
  openid_not_contains?: String;
  openid_starts_with?: String;
  openid_not_starts_with?: String;
  openid_ends_with?: String;
  openid_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  university?: University;
  university_not?: University;
  university_in?: University[] | University;
  university_not_in?: University[] | University;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  Gender?: Gender;
  Gender_not?: Gender;
  Gender_in?: Gender[] | Gender;
  Gender_not_in?: Gender[] | Gender;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  expectPay?: Int;
  expectPay_not?: Int;
  expectPay_in?: Int[] | Int;
  expectPay_not_in?: Int[] | Int;
  expectPay_lt?: Int;
  expectPay_lte?: Int;
  expectPay_gt?: Int;
  expectPay_gte?: Int;
  authstatus?: AuthStatus;
  authstatus_not?: AuthStatus;
  authstatus_in?: AuthStatus[] | AuthStatus;
  authstatus_not_in?: AuthStatus[] | AuthStatus;
  subjects_every?: SubjectWhereInput;
  subjects_some?: SubjectWhereInput;
  subjects_none?: SubjectWhereInput;
  starList_every?: ParentWhereInput;
  starList_some?: ParentWhereInput;
  starList_none?: ParentWhereInput;
  avalible_every?: AvalibelTimeWhereInput;
  avalible_some?: AvalibelTimeWhereInput;
  avalible_none?: AvalibelTimeWhereInput;
  studentDetail?: StudentDetailWhereInput;
  invitations_every?: InvitationWhereInput;
  invitations_some?: InvitationWhereInput;
  invitations_none?: InvitationWhereInput;
  order_every?: OrderWhereInput;
  order_some?: OrderWhereInput;
  order_none?: OrderWhereInput;
  AND?: StudentWhereInput[] | StudentWhereInput;
  OR?: StudentWhereInput[] | StudentWhereInput;
  NOT?: StudentWhereInput[] | StudentWhereInput;
}

export interface StudentDetailWhereInput {
  selfIntro?: String;
  selfIntro_not?: String;
  selfIntro_in?: String[] | String;
  selfIntro_not_in?: String[] | String;
  selfIntro_lt?: String;
  selfIntro_lte?: String;
  selfIntro_gt?: String;
  selfIntro_gte?: String;
  selfIntro_contains?: String;
  selfIntro_not_contains?: String;
  selfIntro_starts_with?: String;
  selfIntro_not_starts_with?: String;
  selfIntro_ends_with?: String;
  selfIntro_not_ends_with?: String;
  grades?: String;
  grades_not?: String;
  grades_in?: String[] | String;
  grades_not_in?: String[] | String;
  grades_lt?: String;
  grades_lte?: String;
  grades_gt?: String;
  grades_gte?: String;
  grades_contains?: String;
  grades_not_contains?: String;
  grades_starts_with?: String;
  grades_not_starts_with?: String;
  grades_ends_with?: String;
  grades_not_ends_with?: String;
  exprience?: String;
  exprience_not?: String;
  exprience_in?: String[] | String;
  exprience_not_in?: String[] | String;
  exprience_lt?: String;
  exprience_lte?: String;
  exprience_gt?: String;
  exprience_gte?: String;
  exprience_contains?: String;
  exprience_not_contains?: String;
  exprience_starts_with?: String;
  exprience_not_starts_with?: String;
  exprience_ends_with?: String;
  exprience_not_ends_with?: String;
  AND?: StudentDetailWhereInput[] | StudentDetailWhereInput;
  OR?: StudentDetailWhereInput[] | StudentDetailWhereInput;
  NOT?: StudentDetailWhereInput[] | StudentDetailWhereInput;
}

export interface InvitationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  stuednt?: StudentWhereInput;
  parents?: ParentWhereInput;
  invitor?: Invitor;
  invitor_not?: Invitor;
  invitor_in?: Invitor[] | Invitor;
  invitor_not_in?: Invitor[] | Invitor;
  status?: InvitationStatus;
  status_not?: InvitationStatus;
  status_in?: InvitationStatus[] | InvitationStatus;
  status_not_in?: InvitationStatus[] | InvitationStatus;
  AND?: InvitationWhereInput[] | InvitationWhereInput;
  OR?: InvitationWhereInput[] | InvitationWhereInput;
  NOT?: InvitationWhereInput[] | InvitationWhereInput;
}

export interface OrderWhereInput {
  order?: String;
  order_not?: String;
  order_in?: String[] | String;
  order_not_in?: String[] | String;
  order_lt?: String;
  order_lte?: String;
  order_gt?: String;
  order_gte?: String;
  order_contains?: String;
  order_not_contains?: String;
  order_starts_with?: String;
  order_not_starts_with?: String;
  order_ends_with?: String;
  order_not_ends_with?: String;
  stuednt?: StudentWhereInput;
  parents?: ParentWhereInput;
  status?: OrderStatus;
  status_not?: OrderStatus;
  status_in?: OrderStatus[] | OrderStatus;
  status_not_in?: OrderStatus[] | OrderStatus;
  AND?: OrderWhereInput[] | OrderWhereInput;
  OR?: OrderWhereInput[] | OrderWhereInput;
  NOT?: OrderWhereInput[] | OrderWhereInput;
}

export type LongTermWhereUniqueInput = AtLeastOne<{
  longTermId: ID_Input;
}>;

export type OrderWhereUniqueInput = AtLeastOne<{
  order: String;
}>;

export type ParentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  phone?: String;
  name?: String;
  email?: String;
}>;

export type ShortTermWhereUniqueInput = AtLeastOne<{
  shortTermId: ID_Input;
}>;

export type StudentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  UnionID?: String;
  openid?: String;
  phone?: String;
  name?: String;
  email?: String;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  UnionID: String;
}>;

export interface UserWhereInput {
  UnionID?: String;
  UnionID_not?: String;
  UnionID_in?: String[] | String;
  UnionID_not_in?: String[] | String;
  UnionID_lt?: String;
  UnionID_lte?: String;
  UnionID_gt?: String;
  UnionID_gte?: String;
  UnionID_contains?: String;
  UnionID_not_contains?: String;
  UnionID_starts_with?: String;
  UnionID_not_starts_with?: String;
  UnionID_ends_with?: String;
  UnionID_not_ends_with?: String;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface AvalibelTimeCreateInput {
  day: Day;
  detail: DetailTime;
}

export interface AvalibelTimeUpdateManyMutationInput {
  day?: Day;
  detail?: DetailTime;
}

export interface BasicTermInfoCreateInput {
  termId: ID_Input;
  subjects?: SubjectCreateManyInput;
  pay?: Int;
  childGender?: Gender;
  TeacherGender?: SelectGender;
  teacherReuqire?: String;
  childStatus?: String;
  longTerm?: LongTermCreateOneInput;
  shortTerm?: ShortTermCreateOneInput;
}

export interface SubjectCreateManyInput {
  create?: SubjectCreateInput[] | SubjectCreateInput;
}

export interface SubjectCreateInput {
  name: SubjectName;
  level?: SubjectCreatelevelInput;
}

export interface SubjectCreatelevelInput {
  set?: Level[] | Level;
}

export interface LongTermCreateOneInput {
  create?: LongTermCreateInput;
  connect?: LongTermWhereUniqueInput;
}

export interface LongTermCreateInput {
  longTermId: ID_Input;
  lessonTime?: Int;
  days?: Int;
  timeList?: AvalibelTimeCreateManyInput;
}

export interface AvalibelTimeCreateManyInput {
  create?: AvalibelTimeCreateInput[] | AvalibelTimeCreateInput;
}

export interface ShortTermCreateOneInput {
  create?: ShortTermCreateInput;
  connect?: ShortTermWhereUniqueInput;
}

export interface ShortTermCreateInput {
  shortTermId: ID_Input;
  timeList?: ShortTermCreatetimeListInput;
}

export interface ShortTermCreatetimeListInput {
  set?: DateTimeInput[] | DateTimeInput;
}

export interface BasicTermInfoUpdateInput {
  termId?: ID_Input;
  subjects?: SubjectUpdateManyInput;
  pay?: Int;
  childGender?: Gender;
  TeacherGender?: SelectGender;
  teacherReuqire?: String;
  childStatus?: String;
  longTerm?: LongTermUpdateOneInput;
  shortTerm?: ShortTermUpdateOneInput;
}

export interface SubjectUpdateManyInput {
  create?: SubjectCreateInput[] | SubjectCreateInput;
  deleteMany?: SubjectScalarWhereInput[] | SubjectScalarWhereInput;
  updateMany?:
    | SubjectUpdateManyWithWhereNestedInput[]
    | SubjectUpdateManyWithWhereNestedInput;
}

export interface SubjectScalarWhereInput {
  name?: SubjectName;
  name_not?: SubjectName;
  name_in?: SubjectName[] | SubjectName;
  name_not_in?: SubjectName[] | SubjectName;
  AND?: SubjectScalarWhereInput[] | SubjectScalarWhereInput;
  OR?: SubjectScalarWhereInput[] | SubjectScalarWhereInput;
  NOT?: SubjectScalarWhereInput[] | SubjectScalarWhereInput;
}

export interface SubjectUpdateManyWithWhereNestedInput {
  where: SubjectScalarWhereInput;
  data: SubjectUpdateManyDataInput;
}

export interface SubjectUpdateManyDataInput {
  name?: SubjectName;
  level?: SubjectUpdatelevelInput;
}

export interface SubjectUpdatelevelInput {
  set?: Level[] | Level;
}

export interface LongTermUpdateOneInput {
  create?: LongTermCreateInput;
  update?: LongTermUpdateDataInput;
  upsert?: LongTermUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LongTermWhereUniqueInput;
}

export interface LongTermUpdateDataInput {
  longTermId?: ID_Input;
  lessonTime?: Int;
  days?: Int;
  timeList?: AvalibelTimeUpdateManyInput;
}

export interface AvalibelTimeUpdateManyInput {
  create?: AvalibelTimeCreateInput[] | AvalibelTimeCreateInput;
  deleteMany?: AvalibelTimeScalarWhereInput[] | AvalibelTimeScalarWhereInput;
  updateMany?:
    | AvalibelTimeUpdateManyWithWhereNestedInput[]
    | AvalibelTimeUpdateManyWithWhereNestedInput;
}

export interface AvalibelTimeScalarWhereInput {
  day?: Day;
  day_not?: Day;
  day_in?: Day[] | Day;
  day_not_in?: Day[] | Day;
  detail?: DetailTime;
  detail_not?: DetailTime;
  detail_in?: DetailTime[] | DetailTime;
  detail_not_in?: DetailTime[] | DetailTime;
  AND?: AvalibelTimeScalarWhereInput[] | AvalibelTimeScalarWhereInput;
  OR?: AvalibelTimeScalarWhereInput[] | AvalibelTimeScalarWhereInput;
  NOT?: AvalibelTimeScalarWhereInput[] | AvalibelTimeScalarWhereInput;
}

export interface AvalibelTimeUpdateManyWithWhereNestedInput {
  where: AvalibelTimeScalarWhereInput;
  data: AvalibelTimeUpdateManyDataInput;
}

export interface AvalibelTimeUpdateManyDataInput {
  day?: Day;
  detail?: DetailTime;
}

export interface LongTermUpsertNestedInput {
  update: LongTermUpdateDataInput;
  create: LongTermCreateInput;
}

export interface ShortTermUpdateOneInput {
  create?: ShortTermCreateInput;
  update?: ShortTermUpdateDataInput;
  upsert?: ShortTermUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ShortTermWhereUniqueInput;
}

export interface ShortTermUpdateDataInput {
  shortTermId?: ID_Input;
  timeList?: ShortTermUpdatetimeListInput;
}

export interface ShortTermUpdatetimeListInput {
  set?: DateTimeInput[] | DateTimeInput;
}

export interface ShortTermUpsertNestedInput {
  update: ShortTermUpdateDataInput;
  create: ShortTermCreateInput;
}

export interface BasicTermInfoUpdateManyMutationInput {
  termId?: ID_Input;
  pay?: Int;
  childGender?: Gender;
  TeacherGender?: SelectGender;
  teacherReuqire?: String;
  childStatus?: String;
}

export interface InvitationCreateInput {
  stuednt: StudentCreateOneWithoutInvitationsInput;
  parents: ParentCreateOneWithoutInvitationsInput;
  invitor: Invitor;
  status: InvitationStatus;
}

export interface StudentCreateOneWithoutInvitationsInput {
  create?: StudentCreateWithoutInvitationsInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudentCreateWithoutInvitationsInput {
  UnionID: String;
  openid: String;
  phone: String;
  name: String;
  university: University;
  email: String;
  Gender?: Gender;
  expectPay?: Int;
  authstatus: AuthStatus;
  subjects?: SubjectCreateManyInput;
  starList?: ParentCreateManyWithoutStarListInput;
  avalible?: AvalibelTimeCreateManyInput;
  studentDetail?: StudentDetailCreateOneInput;
  order?: OrderCreateManyWithoutStuedntInput;
}

export interface ParentCreateManyWithoutStarListInput {
  create?:
    | ParentCreateWithoutStarListInput[]
    | ParentCreateWithoutStarListInput;
  connect?: ParentWhereUniqueInput[] | ParentWhereUniqueInput;
}

export interface ParentCreateWithoutStarListInput {
  phone: String;
  name: String;
  address: String;
  email: String;
  UnionID: String;
  authstatus: AuthStatus;
  invitations?: InvitationCreateManyWithoutParentsInput;
  order?: OrderCreateManyWithoutParentsInput;
  publishTerm?: BasicTermInfoCreateManyInput;
}

export interface InvitationCreateManyWithoutParentsInput {
  create?:
    | InvitationCreateWithoutParentsInput[]
    | InvitationCreateWithoutParentsInput;
  connect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
}

export interface InvitationCreateWithoutParentsInput {
  stuednt: StudentCreateOneWithoutInvitationsInput;
  invitor: Invitor;
  status: InvitationStatus;
}

export interface OrderCreateManyWithoutParentsInput {
  create?: OrderCreateWithoutParentsInput[] | OrderCreateWithoutParentsInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
}

export interface OrderCreateWithoutParentsInput {
  order: String;
  stuednt: StudentCreateOneWithoutOrderInput;
  status: OrderStatus;
}

export interface StudentCreateOneWithoutOrderInput {
  create?: StudentCreateWithoutOrderInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudentCreateWithoutOrderInput {
  UnionID: String;
  openid: String;
  phone: String;
  name: String;
  university: University;
  email: String;
  Gender?: Gender;
  expectPay?: Int;
  authstatus: AuthStatus;
  subjects?: SubjectCreateManyInput;
  starList?: ParentCreateManyWithoutStarListInput;
  avalible?: AvalibelTimeCreateManyInput;
  studentDetail?: StudentDetailCreateOneInput;
  invitations?: InvitationCreateManyWithoutStuedntInput;
}

export interface StudentDetailCreateOneInput {
  create?: StudentDetailCreateInput;
}

export interface StudentDetailCreateInput {
  selfIntro: String;
  grades: String;
  exprience: String;
  pictrue?: StudentDetailCreatepictrueInput;
}

export interface StudentDetailCreatepictrueInput {
  set?: String[] | String;
}

export interface InvitationCreateManyWithoutStuedntInput {
  create?:
    | InvitationCreateWithoutStuedntInput[]
    | InvitationCreateWithoutStuedntInput;
  connect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
}

export interface InvitationCreateWithoutStuedntInput {
  parents: ParentCreateOneWithoutInvitationsInput;
  invitor: Invitor;
  status: InvitationStatus;
}

export interface ParentCreateOneWithoutInvitationsInput {
  create?: ParentCreateWithoutInvitationsInput;
  connect?: ParentWhereUniqueInput;
}

export interface ParentCreateWithoutInvitationsInput {
  phone: String;
  name: String;
  address: String;
  email: String;
  UnionID: String;
  authstatus: AuthStatus;
  starList?: StudentCreateManyWithoutStarListInput;
  order?: OrderCreateManyWithoutParentsInput;
  publishTerm?: BasicTermInfoCreateManyInput;
}

export interface StudentCreateManyWithoutStarListInput {
  create?:
    | StudentCreateWithoutStarListInput[]
    | StudentCreateWithoutStarListInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
}

export interface StudentCreateWithoutStarListInput {
  UnionID: String;
  openid: String;
  phone: String;
  name: String;
  university: University;
  email: String;
  Gender?: Gender;
  expectPay?: Int;
  authstatus: AuthStatus;
  subjects?: SubjectCreateManyInput;
  avalible?: AvalibelTimeCreateManyInput;
  studentDetail?: StudentDetailCreateOneInput;
  invitations?: InvitationCreateManyWithoutStuedntInput;
  order?: OrderCreateManyWithoutStuedntInput;
}

export interface OrderCreateManyWithoutStuedntInput {
  create?: OrderCreateWithoutStuedntInput[] | OrderCreateWithoutStuedntInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
}

export interface OrderCreateWithoutStuedntInput {
  order: String;
  parents: ParentCreateOneWithoutOrderInput;
  status: OrderStatus;
}

export interface ParentCreateOneWithoutOrderInput {
  create?: ParentCreateWithoutOrderInput;
  connect?: ParentWhereUniqueInput;
}

export interface ParentCreateWithoutOrderInput {
  phone: String;
  name: String;
  address: String;
  email: String;
  UnionID: String;
  authstatus: AuthStatus;
  starList?: StudentCreateManyWithoutStarListInput;
  invitations?: InvitationCreateManyWithoutParentsInput;
  publishTerm?: BasicTermInfoCreateManyInput;
}

export interface BasicTermInfoCreateManyInput {
  create?: BasicTermInfoCreateInput[] | BasicTermInfoCreateInput;
  connect?: BasicTermInfoWhereUniqueInput[] | BasicTermInfoWhereUniqueInput;
}

export interface InvitationUpdateInput {
  stuednt?: StudentUpdateOneRequiredWithoutInvitationsInput;
  parents?: ParentUpdateOneRequiredWithoutInvitationsInput;
  invitor?: Invitor;
  status?: InvitationStatus;
}

export interface StudentUpdateOneRequiredWithoutInvitationsInput {
  create?: StudentCreateWithoutInvitationsInput;
  update?: StudentUpdateWithoutInvitationsDataInput;
  upsert?: StudentUpsertWithoutInvitationsInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudentUpdateWithoutInvitationsDataInput {
  UnionID?: String;
  openid?: String;
  phone?: String;
  name?: String;
  university?: University;
  email?: String;
  Gender?: Gender;
  expectPay?: Int;
  authstatus?: AuthStatus;
  subjects?: SubjectUpdateManyInput;
  starList?: ParentUpdateManyWithoutStarListInput;
  avalible?: AvalibelTimeUpdateManyInput;
  studentDetail?: StudentDetailUpdateOneInput;
  order?: OrderUpdateManyWithoutStuedntInput;
}

export interface ParentUpdateManyWithoutStarListInput {
  create?:
    | ParentCreateWithoutStarListInput[]
    | ParentCreateWithoutStarListInput;
  delete?: ParentWhereUniqueInput[] | ParentWhereUniqueInput;
  connect?: ParentWhereUniqueInput[] | ParentWhereUniqueInput;
  disconnect?: ParentWhereUniqueInput[] | ParentWhereUniqueInput;
  update?:
    | ParentUpdateWithWhereUniqueWithoutStarListInput[]
    | ParentUpdateWithWhereUniqueWithoutStarListInput;
  upsert?:
    | ParentUpsertWithWhereUniqueWithoutStarListInput[]
    | ParentUpsertWithWhereUniqueWithoutStarListInput;
  deleteMany?: ParentScalarWhereInput[] | ParentScalarWhereInput;
  updateMany?:
    | ParentUpdateManyWithWhereNestedInput[]
    | ParentUpdateManyWithWhereNestedInput;
}

export interface ParentUpdateWithWhereUniqueWithoutStarListInput {
  where: ParentWhereUniqueInput;
  data: ParentUpdateWithoutStarListDataInput;
}

export interface ParentUpdateWithoutStarListDataInput {
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  UnionID?: String;
  authstatus?: AuthStatus;
  invitations?: InvitationUpdateManyWithoutParentsInput;
  order?: OrderUpdateManyWithoutParentsInput;
  publishTerm?: BasicTermInfoUpdateManyInput;
}

export interface InvitationUpdateManyWithoutParentsInput {
  create?:
    | InvitationCreateWithoutParentsInput[]
    | InvitationCreateWithoutParentsInput;
  delete?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  connect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  disconnect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  update?:
    | InvitationUpdateWithWhereUniqueWithoutParentsInput[]
    | InvitationUpdateWithWhereUniqueWithoutParentsInput;
  upsert?:
    | InvitationUpsertWithWhereUniqueWithoutParentsInput[]
    | InvitationUpsertWithWhereUniqueWithoutParentsInput;
  deleteMany?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
  updateMany?:
    | InvitationUpdateManyWithWhereNestedInput[]
    | InvitationUpdateManyWithWhereNestedInput;
}

export interface InvitationUpdateWithWhereUniqueWithoutParentsInput {
  where: InvitationWhereUniqueInput;
  data: InvitationUpdateWithoutParentsDataInput;
}

export interface InvitationUpdateWithoutParentsDataInput {
  stuednt?: StudentUpdateOneRequiredWithoutInvitationsInput;
  invitor?: Invitor;
  status?: InvitationStatus;
}

export interface InvitationUpsertWithWhereUniqueWithoutParentsInput {
  where: InvitationWhereUniqueInput;
  update: InvitationUpdateWithoutParentsDataInput;
  create: InvitationCreateWithoutParentsInput;
}

export interface InvitationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  invitor?: Invitor;
  invitor_not?: Invitor;
  invitor_in?: Invitor[] | Invitor;
  invitor_not_in?: Invitor[] | Invitor;
  status?: InvitationStatus;
  status_not?: InvitationStatus;
  status_in?: InvitationStatus[] | InvitationStatus;
  status_not_in?: InvitationStatus[] | InvitationStatus;
  AND?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
  OR?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
  NOT?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
}

export interface InvitationUpdateManyWithWhereNestedInput {
  where: InvitationScalarWhereInput;
  data: InvitationUpdateManyDataInput;
}

export interface InvitationUpdateManyDataInput {
  invitor?: Invitor;
  status?: InvitationStatus;
}

export interface OrderUpdateManyWithoutParentsInput {
  create?: OrderCreateWithoutParentsInput[] | OrderCreateWithoutParentsInput;
  delete?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  disconnect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  update?:
    | OrderUpdateWithWhereUniqueWithoutParentsInput[]
    | OrderUpdateWithWhereUniqueWithoutParentsInput;
  upsert?:
    | OrderUpsertWithWhereUniqueWithoutParentsInput[]
    | OrderUpsertWithWhereUniqueWithoutParentsInput;
  deleteMany?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  updateMany?:
    | OrderUpdateManyWithWhereNestedInput[]
    | OrderUpdateManyWithWhereNestedInput;
}

export interface OrderUpdateWithWhereUniqueWithoutParentsInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutParentsDataInput;
}

export interface OrderUpdateWithoutParentsDataInput {
  order?: String;
  stuednt?: StudentUpdateOneRequiredWithoutOrderInput;
  status?: OrderStatus;
}

export interface StudentUpdateOneRequiredWithoutOrderInput {
  create?: StudentCreateWithoutOrderInput;
  update?: StudentUpdateWithoutOrderDataInput;
  upsert?: StudentUpsertWithoutOrderInput;
  connect?: StudentWhereUniqueInput;
}

export interface StudentUpdateWithoutOrderDataInput {
  UnionID?: String;
  openid?: String;
  phone?: String;
  name?: String;
  university?: University;
  email?: String;
  Gender?: Gender;
  expectPay?: Int;
  authstatus?: AuthStatus;
  subjects?: SubjectUpdateManyInput;
  starList?: ParentUpdateManyWithoutStarListInput;
  avalible?: AvalibelTimeUpdateManyInput;
  studentDetail?: StudentDetailUpdateOneInput;
  invitations?: InvitationUpdateManyWithoutStuedntInput;
}

export interface StudentDetailUpdateOneInput {
  create?: StudentDetailCreateInput;
  update?: StudentDetailUpdateDataInput;
  upsert?: StudentDetailUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface StudentDetailUpdateDataInput {
  selfIntro?: String;
  grades?: String;
  exprience?: String;
  pictrue?: StudentDetailUpdatepictrueInput;
}

export interface StudentDetailUpdatepictrueInput {
  set?: String[] | String;
}

export interface StudentDetailUpsertNestedInput {
  update: StudentDetailUpdateDataInput;
  create: StudentDetailCreateInput;
}

export interface InvitationUpdateManyWithoutStuedntInput {
  create?:
    | InvitationCreateWithoutStuedntInput[]
    | InvitationCreateWithoutStuedntInput;
  delete?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  connect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  disconnect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  update?:
    | InvitationUpdateWithWhereUniqueWithoutStuedntInput[]
    | InvitationUpdateWithWhereUniqueWithoutStuedntInput;
  upsert?:
    | InvitationUpsertWithWhereUniqueWithoutStuedntInput[]
    | InvitationUpsertWithWhereUniqueWithoutStuedntInput;
  deleteMany?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
  updateMany?:
    | InvitationUpdateManyWithWhereNestedInput[]
    | InvitationUpdateManyWithWhereNestedInput;
}

export interface InvitationUpdateWithWhereUniqueWithoutStuedntInput {
  where: InvitationWhereUniqueInput;
  data: InvitationUpdateWithoutStuedntDataInput;
}

export interface InvitationUpdateWithoutStuedntDataInput {
  parents?: ParentUpdateOneRequiredWithoutInvitationsInput;
  invitor?: Invitor;
  status?: InvitationStatus;
}

export interface ParentUpdateOneRequiredWithoutInvitationsInput {
  create?: ParentCreateWithoutInvitationsInput;
  update?: ParentUpdateWithoutInvitationsDataInput;
  upsert?: ParentUpsertWithoutInvitationsInput;
  connect?: ParentWhereUniqueInput;
}

export interface ParentUpdateWithoutInvitationsDataInput {
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  UnionID?: String;
  authstatus?: AuthStatus;
  starList?: StudentUpdateManyWithoutStarListInput;
  order?: OrderUpdateManyWithoutParentsInput;
  publishTerm?: BasicTermInfoUpdateManyInput;
}

export interface StudentUpdateManyWithoutStarListInput {
  create?:
    | StudentCreateWithoutStarListInput[]
    | StudentCreateWithoutStarListInput;
  delete?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  connect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  disconnect?: StudentWhereUniqueInput[] | StudentWhereUniqueInput;
  update?:
    | StudentUpdateWithWhereUniqueWithoutStarListInput[]
    | StudentUpdateWithWhereUniqueWithoutStarListInput;
  upsert?:
    | StudentUpsertWithWhereUniqueWithoutStarListInput[]
    | StudentUpsertWithWhereUniqueWithoutStarListInput;
  deleteMany?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  updateMany?:
    | StudentUpdateManyWithWhereNestedInput[]
    | StudentUpdateManyWithWhereNestedInput;
}

export interface StudentUpdateWithWhereUniqueWithoutStarListInput {
  where: StudentWhereUniqueInput;
  data: StudentUpdateWithoutStarListDataInput;
}

export interface StudentUpdateWithoutStarListDataInput {
  UnionID?: String;
  openid?: String;
  phone?: String;
  name?: String;
  university?: University;
  email?: String;
  Gender?: Gender;
  expectPay?: Int;
  authstatus?: AuthStatus;
  subjects?: SubjectUpdateManyInput;
  avalible?: AvalibelTimeUpdateManyInput;
  studentDetail?: StudentDetailUpdateOneInput;
  invitations?: InvitationUpdateManyWithoutStuedntInput;
  order?: OrderUpdateManyWithoutStuedntInput;
}

export interface OrderUpdateManyWithoutStuedntInput {
  create?: OrderCreateWithoutStuedntInput[] | OrderCreateWithoutStuedntInput;
  delete?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  connect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  disconnect?: OrderWhereUniqueInput[] | OrderWhereUniqueInput;
  update?:
    | OrderUpdateWithWhereUniqueWithoutStuedntInput[]
    | OrderUpdateWithWhereUniqueWithoutStuedntInput;
  upsert?:
    | OrderUpsertWithWhereUniqueWithoutStuedntInput[]
    | OrderUpsertWithWhereUniqueWithoutStuedntInput;
  deleteMany?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  updateMany?:
    | OrderUpdateManyWithWhereNestedInput[]
    | OrderUpdateManyWithWhereNestedInput;
}

export interface OrderUpdateWithWhereUniqueWithoutStuedntInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutStuedntDataInput;
}

export interface OrderUpdateWithoutStuedntDataInput {
  order?: String;
  parents?: ParentUpdateOneRequiredWithoutOrderInput;
  status?: OrderStatus;
}

export interface ParentUpdateOneRequiredWithoutOrderInput {
  create?: ParentCreateWithoutOrderInput;
  update?: ParentUpdateWithoutOrderDataInput;
  upsert?: ParentUpsertWithoutOrderInput;
  connect?: ParentWhereUniqueInput;
}

export interface ParentUpdateWithoutOrderDataInput {
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  UnionID?: String;
  authstatus?: AuthStatus;
  starList?: StudentUpdateManyWithoutStarListInput;
  invitations?: InvitationUpdateManyWithoutParentsInput;
  publishTerm?: BasicTermInfoUpdateManyInput;
}

export interface BasicTermInfoUpdateManyInput {
  create?: BasicTermInfoCreateInput[] | BasicTermInfoCreateInput;
  update?:
    | BasicTermInfoUpdateWithWhereUniqueNestedInput[]
    | BasicTermInfoUpdateWithWhereUniqueNestedInput;
  upsert?:
    | BasicTermInfoUpsertWithWhereUniqueNestedInput[]
    | BasicTermInfoUpsertWithWhereUniqueNestedInput;
  delete?: BasicTermInfoWhereUniqueInput[] | BasicTermInfoWhereUniqueInput;
  connect?: BasicTermInfoWhereUniqueInput[] | BasicTermInfoWhereUniqueInput;
  disconnect?: BasicTermInfoWhereUniqueInput[] | BasicTermInfoWhereUniqueInput;
  deleteMany?: BasicTermInfoScalarWhereInput[] | BasicTermInfoScalarWhereInput;
  updateMany?:
    | BasicTermInfoUpdateManyWithWhereNestedInput[]
    | BasicTermInfoUpdateManyWithWhereNestedInput;
}

export interface BasicTermInfoUpdateWithWhereUniqueNestedInput {
  where: BasicTermInfoWhereUniqueInput;
  data: BasicTermInfoUpdateDataInput;
}

export interface BasicTermInfoUpdateDataInput {
  termId?: ID_Input;
  subjects?: SubjectUpdateManyInput;
  pay?: Int;
  childGender?: Gender;
  TeacherGender?: SelectGender;
  teacherReuqire?: String;
  childStatus?: String;
  longTerm?: LongTermUpdateOneInput;
  shortTerm?: ShortTermUpdateOneInput;
}

export interface BasicTermInfoUpsertWithWhereUniqueNestedInput {
  where: BasicTermInfoWhereUniqueInput;
  update: BasicTermInfoUpdateDataInput;
  create: BasicTermInfoCreateInput;
}

export interface BasicTermInfoScalarWhereInput {
  termId?: ID_Input;
  termId_not?: ID_Input;
  termId_in?: ID_Input[] | ID_Input;
  termId_not_in?: ID_Input[] | ID_Input;
  termId_lt?: ID_Input;
  termId_lte?: ID_Input;
  termId_gt?: ID_Input;
  termId_gte?: ID_Input;
  termId_contains?: ID_Input;
  termId_not_contains?: ID_Input;
  termId_starts_with?: ID_Input;
  termId_not_starts_with?: ID_Input;
  termId_ends_with?: ID_Input;
  termId_not_ends_with?: ID_Input;
  pay?: Int;
  pay_not?: Int;
  pay_in?: Int[] | Int;
  pay_not_in?: Int[] | Int;
  pay_lt?: Int;
  pay_lte?: Int;
  pay_gt?: Int;
  pay_gte?: Int;
  childGender?: Gender;
  childGender_not?: Gender;
  childGender_in?: Gender[] | Gender;
  childGender_not_in?: Gender[] | Gender;
  TeacherGender?: SelectGender;
  TeacherGender_not?: SelectGender;
  TeacherGender_in?: SelectGender[] | SelectGender;
  TeacherGender_not_in?: SelectGender[] | SelectGender;
  teacherReuqire?: String;
  teacherReuqire_not?: String;
  teacherReuqire_in?: String[] | String;
  teacherReuqire_not_in?: String[] | String;
  teacherReuqire_lt?: String;
  teacherReuqire_lte?: String;
  teacherReuqire_gt?: String;
  teacherReuqire_gte?: String;
  teacherReuqire_contains?: String;
  teacherReuqire_not_contains?: String;
  teacherReuqire_starts_with?: String;
  teacherReuqire_not_starts_with?: String;
  teacherReuqire_ends_with?: String;
  teacherReuqire_not_ends_with?: String;
  childStatus?: String;
  childStatus_not?: String;
  childStatus_in?: String[] | String;
  childStatus_not_in?: String[] | String;
  childStatus_lt?: String;
  childStatus_lte?: String;
  childStatus_gt?: String;
  childStatus_gte?: String;
  childStatus_contains?: String;
  childStatus_not_contains?: String;
  childStatus_starts_with?: String;
  childStatus_not_starts_with?: String;
  childStatus_ends_with?: String;
  childStatus_not_ends_with?: String;
  AND?: BasicTermInfoScalarWhereInput[] | BasicTermInfoScalarWhereInput;
  OR?: BasicTermInfoScalarWhereInput[] | BasicTermInfoScalarWhereInput;
  NOT?: BasicTermInfoScalarWhereInput[] | BasicTermInfoScalarWhereInput;
}

export interface BasicTermInfoUpdateManyWithWhereNestedInput {
  where: BasicTermInfoScalarWhereInput;
  data: BasicTermInfoUpdateManyDataInput;
}

export interface BasicTermInfoUpdateManyDataInput {
  termId?: ID_Input;
  pay?: Int;
  childGender?: Gender;
  TeacherGender?: SelectGender;
  teacherReuqire?: String;
  childStatus?: String;
}

export interface ParentUpsertWithoutOrderInput {
  update: ParentUpdateWithoutOrderDataInput;
  create: ParentCreateWithoutOrderInput;
}

export interface OrderUpsertWithWhereUniqueWithoutStuedntInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutStuedntDataInput;
  create: OrderCreateWithoutStuedntInput;
}

export interface OrderScalarWhereInput {
  order?: String;
  order_not?: String;
  order_in?: String[] | String;
  order_not_in?: String[] | String;
  order_lt?: String;
  order_lte?: String;
  order_gt?: String;
  order_gte?: String;
  order_contains?: String;
  order_not_contains?: String;
  order_starts_with?: String;
  order_not_starts_with?: String;
  order_ends_with?: String;
  order_not_ends_with?: String;
  status?: OrderStatus;
  status_not?: OrderStatus;
  status_in?: OrderStatus[] | OrderStatus;
  status_not_in?: OrderStatus[] | OrderStatus;
  AND?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  OR?: OrderScalarWhereInput[] | OrderScalarWhereInput;
  NOT?: OrderScalarWhereInput[] | OrderScalarWhereInput;
}

export interface OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput;
  data: OrderUpdateManyDataInput;
}

export interface OrderUpdateManyDataInput {
  order?: String;
  status?: OrderStatus;
}

export interface StudentUpsertWithWhereUniqueWithoutStarListInput {
  where: StudentWhereUniqueInput;
  update: StudentUpdateWithoutStarListDataInput;
  create: StudentCreateWithoutStarListInput;
}

export interface StudentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  UnionID?: String;
  UnionID_not?: String;
  UnionID_in?: String[] | String;
  UnionID_not_in?: String[] | String;
  UnionID_lt?: String;
  UnionID_lte?: String;
  UnionID_gt?: String;
  UnionID_gte?: String;
  UnionID_contains?: String;
  UnionID_not_contains?: String;
  UnionID_starts_with?: String;
  UnionID_not_starts_with?: String;
  UnionID_ends_with?: String;
  UnionID_not_ends_with?: String;
  openid?: String;
  openid_not?: String;
  openid_in?: String[] | String;
  openid_not_in?: String[] | String;
  openid_lt?: String;
  openid_lte?: String;
  openid_gt?: String;
  openid_gte?: String;
  openid_contains?: String;
  openid_not_contains?: String;
  openid_starts_with?: String;
  openid_not_starts_with?: String;
  openid_ends_with?: String;
  openid_not_ends_with?: String;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  university?: University;
  university_not?: University;
  university_in?: University[] | University;
  university_not_in?: University[] | University;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  Gender?: Gender;
  Gender_not?: Gender;
  Gender_in?: Gender[] | Gender;
  Gender_not_in?: Gender[] | Gender;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  expectPay?: Int;
  expectPay_not?: Int;
  expectPay_in?: Int[] | Int;
  expectPay_not_in?: Int[] | Int;
  expectPay_lt?: Int;
  expectPay_lte?: Int;
  expectPay_gt?: Int;
  expectPay_gte?: Int;
  authstatus?: AuthStatus;
  authstatus_not?: AuthStatus;
  authstatus_in?: AuthStatus[] | AuthStatus;
  authstatus_not_in?: AuthStatus[] | AuthStatus;
  AND?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  OR?: StudentScalarWhereInput[] | StudentScalarWhereInput;
  NOT?: StudentScalarWhereInput[] | StudentScalarWhereInput;
}

export interface StudentUpdateManyWithWhereNestedInput {
  where: StudentScalarWhereInput;
  data: StudentUpdateManyDataInput;
}

export interface StudentUpdateManyDataInput {
  UnionID?: String;
  openid?: String;
  phone?: String;
  name?: String;
  university?: University;
  email?: String;
  Gender?: Gender;
  expectPay?: Int;
  authstatus?: AuthStatus;
}

export interface ParentUpsertWithoutInvitationsInput {
  update: ParentUpdateWithoutInvitationsDataInput;
  create: ParentCreateWithoutInvitationsInput;
}

export interface InvitationUpsertWithWhereUniqueWithoutStuedntInput {
  where: InvitationWhereUniqueInput;
  update: InvitationUpdateWithoutStuedntDataInput;
  create: InvitationCreateWithoutStuedntInput;
}

export interface StudentUpsertWithoutOrderInput {
  update: StudentUpdateWithoutOrderDataInput;
  create: StudentCreateWithoutOrderInput;
}

export interface OrderUpsertWithWhereUniqueWithoutParentsInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutParentsDataInput;
  create: OrderCreateWithoutParentsInput;
}

export interface ParentUpsertWithWhereUniqueWithoutStarListInput {
  where: ParentWhereUniqueInput;
  update: ParentUpdateWithoutStarListDataInput;
  create: ParentCreateWithoutStarListInput;
}

export interface ParentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  phone?: String;
  phone_not?: String;
  phone_in?: String[] | String;
  phone_not_in?: String[] | String;
  phone_lt?: String;
  phone_lte?: String;
  phone_gt?: String;
  phone_gte?: String;
  phone_contains?: String;
  phone_not_contains?: String;
  phone_starts_with?: String;
  phone_not_starts_with?: String;
  phone_ends_with?: String;
  phone_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  UnionID?: String;
  UnionID_not?: String;
  UnionID_in?: String[] | String;
  UnionID_not_in?: String[] | String;
  UnionID_lt?: String;
  UnionID_lte?: String;
  UnionID_gt?: String;
  UnionID_gte?: String;
  UnionID_contains?: String;
  UnionID_not_contains?: String;
  UnionID_starts_with?: String;
  UnionID_not_starts_with?: String;
  UnionID_ends_with?: String;
  UnionID_not_ends_with?: String;
  authstatus?: AuthStatus;
  authstatus_not?: AuthStatus;
  authstatus_in?: AuthStatus[] | AuthStatus;
  authstatus_not_in?: AuthStatus[] | AuthStatus;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ParentScalarWhereInput[] | ParentScalarWhereInput;
  OR?: ParentScalarWhereInput[] | ParentScalarWhereInput;
  NOT?: ParentScalarWhereInput[] | ParentScalarWhereInput;
}

export interface ParentUpdateManyWithWhereNestedInput {
  where: ParentScalarWhereInput;
  data: ParentUpdateManyDataInput;
}

export interface ParentUpdateManyDataInput {
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  UnionID?: String;
  authstatus?: AuthStatus;
}

export interface StudentUpsertWithoutInvitationsInput {
  update: StudentUpdateWithoutInvitationsDataInput;
  create: StudentCreateWithoutInvitationsInput;
}

export interface InvitationUpdateManyMutationInput {
  invitor?: Invitor;
  status?: InvitationStatus;
}

export interface LongTermUpdateInput {
  longTermId?: ID_Input;
  lessonTime?: Int;
  days?: Int;
  timeList?: AvalibelTimeUpdateManyInput;
}

export interface LongTermUpdateManyMutationInput {
  longTermId?: ID_Input;
  lessonTime?: Int;
  days?: Int;
}

export interface OrderCreateInput {
  order: String;
  stuednt: StudentCreateOneWithoutOrderInput;
  parents: ParentCreateOneWithoutOrderInput;
  status: OrderStatus;
}

export interface OrderUpdateInput {
  order?: String;
  stuednt?: StudentUpdateOneRequiredWithoutOrderInput;
  parents?: ParentUpdateOneRequiredWithoutOrderInput;
  status?: OrderStatus;
}

export interface OrderUpdateManyMutationInput {
  order?: String;
  status?: OrderStatus;
}

export interface ParentCreateInput {
  phone: String;
  name: String;
  address: String;
  email: String;
  UnionID: String;
  authstatus: AuthStatus;
  starList?: StudentCreateManyWithoutStarListInput;
  invitations?: InvitationCreateManyWithoutParentsInput;
  order?: OrderCreateManyWithoutParentsInput;
  publishTerm?: BasicTermInfoCreateManyInput;
}

export interface ParentUpdateInput {
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  UnionID?: String;
  authstatus?: AuthStatus;
  starList?: StudentUpdateManyWithoutStarListInput;
  invitations?: InvitationUpdateManyWithoutParentsInput;
  order?: OrderUpdateManyWithoutParentsInput;
  publishTerm?: BasicTermInfoUpdateManyInput;
}

export interface ParentUpdateManyMutationInput {
  phone?: String;
  name?: String;
  address?: String;
  email?: String;
  UnionID?: String;
  authstatus?: AuthStatus;
}

export interface ShortTermUpdateInput {
  shortTermId?: ID_Input;
  timeList?: ShortTermUpdatetimeListInput;
}

export interface ShortTermUpdateManyMutationInput {
  shortTermId?: ID_Input;
  timeList?: ShortTermUpdatetimeListInput;
}

export interface StudentCreateInput {
  UnionID: String;
  openid: String;
  phone: String;
  name: String;
  university: University;
  email: String;
  Gender?: Gender;
  expectPay?: Int;
  authstatus: AuthStatus;
  subjects?: SubjectCreateManyInput;
  starList?: ParentCreateManyWithoutStarListInput;
  avalible?: AvalibelTimeCreateManyInput;
  studentDetail?: StudentDetailCreateOneInput;
  invitations?: InvitationCreateManyWithoutStuedntInput;
  order?: OrderCreateManyWithoutStuedntInput;
}

export interface StudentUpdateInput {
  UnionID?: String;
  openid?: String;
  phone?: String;
  name?: String;
  university?: University;
  email?: String;
  Gender?: Gender;
  expectPay?: Int;
  authstatus?: AuthStatus;
  subjects?: SubjectUpdateManyInput;
  starList?: ParentUpdateManyWithoutStarListInput;
  avalible?: AvalibelTimeUpdateManyInput;
  studentDetail?: StudentDetailUpdateOneInput;
  invitations?: InvitationUpdateManyWithoutStuedntInput;
  order?: OrderUpdateManyWithoutStuedntInput;
}

export interface StudentUpdateManyMutationInput {
  UnionID?: String;
  openid?: String;
  phone?: String;
  name?: String;
  university?: University;
  email?: String;
  Gender?: Gender;
  expectPay?: Int;
  authstatus?: AuthStatus;
}

export interface StudentDetailUpdateManyMutationInput {
  selfIntro?: String;
  grades?: String;
  exprience?: String;
  pictrue?: StudentDetailUpdatepictrueInput;
}

export interface SubjectUpdateManyMutationInput {
  name?: SubjectName;
  level?: SubjectUpdatelevelInput;
}

export interface UserCreateInput {
  UnionID: String;
}

export interface UserUpdateInput {
  UnionID?: String;
}

export interface UserUpdateManyMutationInput {
  UnionID?: String;
}

export interface AvalibelTimeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AvalibelTimeWhereInput;
  AND?:
    | AvalibelTimeSubscriptionWhereInput[]
    | AvalibelTimeSubscriptionWhereInput;
  OR?:
    | AvalibelTimeSubscriptionWhereInput[]
    | AvalibelTimeSubscriptionWhereInput;
  NOT?:
    | AvalibelTimeSubscriptionWhereInput[]
    | AvalibelTimeSubscriptionWhereInput;
}

export interface BasicTermInfoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BasicTermInfoWhereInput;
  AND?:
    | BasicTermInfoSubscriptionWhereInput[]
    | BasicTermInfoSubscriptionWhereInput;
  OR?:
    | BasicTermInfoSubscriptionWhereInput[]
    | BasicTermInfoSubscriptionWhereInput;
  NOT?:
    | BasicTermInfoSubscriptionWhereInput[]
    | BasicTermInfoSubscriptionWhereInput;
}

export interface InvitationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InvitationWhereInput;
  AND?: InvitationSubscriptionWhereInput[] | InvitationSubscriptionWhereInput;
  OR?: InvitationSubscriptionWhereInput[] | InvitationSubscriptionWhereInput;
  NOT?: InvitationSubscriptionWhereInput[] | InvitationSubscriptionWhereInput;
}

export interface LongTermSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LongTermWhereInput;
  AND?: LongTermSubscriptionWhereInput[] | LongTermSubscriptionWhereInput;
  OR?: LongTermSubscriptionWhereInput[] | LongTermSubscriptionWhereInput;
  NOT?: LongTermSubscriptionWhereInput[] | LongTermSubscriptionWhereInput;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OrderWhereInput;
  AND?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
  OR?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
  NOT?: OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput;
}

export interface ParentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ParentWhereInput;
  AND?: ParentSubscriptionWhereInput[] | ParentSubscriptionWhereInput;
  OR?: ParentSubscriptionWhereInput[] | ParentSubscriptionWhereInput;
  NOT?: ParentSubscriptionWhereInput[] | ParentSubscriptionWhereInput;
}

export interface ShortTermSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ShortTermWhereInput;
  AND?: ShortTermSubscriptionWhereInput[] | ShortTermSubscriptionWhereInput;
  OR?: ShortTermSubscriptionWhereInput[] | ShortTermSubscriptionWhereInput;
  NOT?: ShortTermSubscriptionWhereInput[] | ShortTermSubscriptionWhereInput;
}

export interface StudentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StudentWhereInput;
  AND?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
  OR?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
  NOT?: StudentSubscriptionWhereInput[] | StudentSubscriptionWhereInput;
}

export interface StudentDetailSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StudentDetailWhereInput;
  AND?:
    | StudentDetailSubscriptionWhereInput[]
    | StudentDetailSubscriptionWhereInput;
  OR?:
    | StudentDetailSubscriptionWhereInput[]
    | StudentDetailSubscriptionWhereInput;
  NOT?:
    | StudentDetailSubscriptionWhereInput[]
    | StudentDetailSubscriptionWhereInput;
}

export interface SubjectSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SubjectWhereInput;
  AND?: SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput;
  OR?: SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput;
  NOT?: SubjectSubscriptionWhereInput[] | SubjectSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AvalibelTime {
  day: Day;
  detail: DetailTime;
}

export interface AvalibelTimePromise
  extends Promise<AvalibelTime>,
    Fragmentable {
  day: () => Promise<Day>;
  detail: () => Promise<DetailTime>;
}

export interface AvalibelTimeSubscription
  extends Promise<AsyncIterator<AvalibelTime>>,
    Fragmentable {
  day: () => Promise<AsyncIterator<Day>>;
  detail: () => Promise<AsyncIterator<DetailTime>>;
}

export interface AvalibelTimeConnection {
  pageInfo: PageInfo;
  edges: AvalibelTimeEdge[];
}

export interface AvalibelTimeConnectionPromise
  extends Promise<AvalibelTimeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AvalibelTimeEdge>>() => T;
  aggregate: <T = AggregateAvalibelTimePromise>() => T;
}

export interface AvalibelTimeConnectionSubscription
  extends Promise<AsyncIterator<AvalibelTimeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AvalibelTimeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAvalibelTimeSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AvalibelTimeEdge {
  node: AvalibelTime;
  cursor: String;
}

export interface AvalibelTimeEdgePromise
  extends Promise<AvalibelTimeEdge>,
    Fragmentable {
  node: <T = AvalibelTimePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AvalibelTimeEdgeSubscription
  extends Promise<AsyncIterator<AvalibelTimeEdge>>,
    Fragmentable {
  node: <T = AvalibelTimeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAvalibelTime {
  count: Int;
}

export interface AggregateAvalibelTimePromise
  extends Promise<AggregateAvalibelTime>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAvalibelTimeSubscription
  extends Promise<AsyncIterator<AggregateAvalibelTime>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BasicTermInfo {
  termId: ID_Output;
  pay?: Int;
  childGender: Gender;
  TeacherGender: SelectGender;
  teacherReuqire?: String;
  childStatus?: String;
}

export interface BasicTermInfoPromise
  extends Promise<BasicTermInfo>,
    Fragmentable {
  termId: () => Promise<ID_Output>;
  subjects: <T = FragmentableArray<Subject>>(args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pay: () => Promise<Int>;
  childGender: () => Promise<Gender>;
  TeacherGender: () => Promise<SelectGender>;
  teacherReuqire: () => Promise<String>;
  childStatus: () => Promise<String>;
  longTerm: <T = LongTermPromise>() => T;
  shortTerm: <T = ShortTermPromise>() => T;
}

export interface BasicTermInfoSubscription
  extends Promise<AsyncIterator<BasicTermInfo>>,
    Fragmentable {
  termId: () => Promise<AsyncIterator<ID_Output>>;
  subjects: <T = Promise<AsyncIterator<SubjectSubscription>>>(args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pay: () => Promise<AsyncIterator<Int>>;
  childGender: () => Promise<AsyncIterator<Gender>>;
  TeacherGender: () => Promise<AsyncIterator<SelectGender>>;
  teacherReuqire: () => Promise<AsyncIterator<String>>;
  childStatus: () => Promise<AsyncIterator<String>>;
  longTerm: <T = LongTermSubscription>() => T;
  shortTerm: <T = ShortTermSubscription>() => T;
}

export interface Subject {
  name: SubjectName;
  level: Level[];
}

export interface SubjectPromise extends Promise<Subject>, Fragmentable {
  name: () => Promise<SubjectName>;
  level: () => Promise<Level[]>;
}

export interface SubjectSubscription
  extends Promise<AsyncIterator<Subject>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<SubjectName>>;
  level: () => Promise<AsyncIterator<Level[]>>;
}

export interface LongTerm {
  longTermId: ID_Output;
  lessonTime?: Int;
  days?: Int;
}

export interface LongTermPromise extends Promise<LongTerm>, Fragmentable {
  longTermId: () => Promise<ID_Output>;
  lessonTime: () => Promise<Int>;
  days: () => Promise<Int>;
  timeList: <T = FragmentableArray<AvalibelTime>>(args?: {
    where?: AvalibelTimeWhereInput;
    orderBy?: AvalibelTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LongTermSubscription
  extends Promise<AsyncIterator<LongTerm>>,
    Fragmentable {
  longTermId: () => Promise<AsyncIterator<ID_Output>>;
  lessonTime: () => Promise<AsyncIterator<Int>>;
  days: () => Promise<AsyncIterator<Int>>;
  timeList: <T = Promise<AsyncIterator<AvalibelTimeSubscription>>>(args?: {
    where?: AvalibelTimeWhereInput;
    orderBy?: AvalibelTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ShortTerm {
  shortTermId: ID_Output;
  timeList: DateTimeOutput[];
}

export interface ShortTermPromise extends Promise<ShortTerm>, Fragmentable {
  shortTermId: () => Promise<ID_Output>;
  timeList: () => Promise<DateTimeOutput[]>;
}

export interface ShortTermSubscription
  extends Promise<AsyncIterator<ShortTerm>>,
    Fragmentable {
  shortTermId: () => Promise<AsyncIterator<ID_Output>>;
  timeList: () => Promise<AsyncIterator<DateTimeOutput[]>>;
}

export interface BasicTermInfoConnection {
  pageInfo: PageInfo;
  edges: BasicTermInfoEdge[];
}

export interface BasicTermInfoConnectionPromise
  extends Promise<BasicTermInfoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BasicTermInfoEdge>>() => T;
  aggregate: <T = AggregateBasicTermInfoPromise>() => T;
}

export interface BasicTermInfoConnectionSubscription
  extends Promise<AsyncIterator<BasicTermInfoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BasicTermInfoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBasicTermInfoSubscription>() => T;
}

export interface BasicTermInfoEdge {
  node: BasicTermInfo;
  cursor: String;
}

export interface BasicTermInfoEdgePromise
  extends Promise<BasicTermInfoEdge>,
    Fragmentable {
  node: <T = BasicTermInfoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BasicTermInfoEdgeSubscription
  extends Promise<AsyncIterator<BasicTermInfoEdge>>,
    Fragmentable {
  node: <T = BasicTermInfoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBasicTermInfo {
  count: Int;
}

export interface AggregateBasicTermInfoPromise
  extends Promise<AggregateBasicTermInfo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBasicTermInfoSubscription
  extends Promise<AsyncIterator<AggregateBasicTermInfo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Invitation {
  id: ID_Output;
  invitor: Invitor;
  status: InvitationStatus;
}

export interface InvitationPromise extends Promise<Invitation>, Fragmentable {
  id: () => Promise<ID_Output>;
  stuednt: <T = StudentPromise>() => T;
  parents: <T = ParentPromise>() => T;
  invitor: () => Promise<Invitor>;
  status: () => Promise<InvitationStatus>;
}

export interface InvitationSubscription
  extends Promise<AsyncIterator<Invitation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  stuednt: <T = StudentSubscription>() => T;
  parents: <T = ParentSubscription>() => T;
  invitor: () => Promise<AsyncIterator<Invitor>>;
  status: () => Promise<AsyncIterator<InvitationStatus>>;
}

export interface Student {
  id: ID_Output;
  UnionID: String;
  openid: String;
  phone: String;
  name: String;
  university: University;
  email: String;
  Gender?: Gender;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  expectPay?: Int;
  authstatus: AuthStatus;
}

export interface StudentPromise extends Promise<Student>, Fragmentable {
  id: () => Promise<ID_Output>;
  UnionID: () => Promise<String>;
  openid: () => Promise<String>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  university: () => Promise<University>;
  email: () => Promise<String>;
  Gender: () => Promise<Gender>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  expectPay: () => Promise<Int>;
  authstatus: () => Promise<AuthStatus>;
  subjects: <T = FragmentableArray<Subject>>(args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  starList: <T = FragmentableArray<Parent>>(args?: {
    where?: ParentWhereInput;
    orderBy?: ParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  avalible: <T = FragmentableArray<AvalibelTime>>(args?: {
    where?: AvalibelTimeWhereInput;
    orderBy?: AvalibelTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  studentDetail: <T = StudentDetailPromise>() => T;
  invitations: <T = FragmentableArray<Invitation>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface StudentSubscription
  extends Promise<AsyncIterator<Student>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  UnionID: () => Promise<AsyncIterator<String>>;
  openid: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  university: () => Promise<AsyncIterator<University>>;
  email: () => Promise<AsyncIterator<String>>;
  Gender: () => Promise<AsyncIterator<Gender>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  expectPay: () => Promise<AsyncIterator<Int>>;
  authstatus: () => Promise<AsyncIterator<AuthStatus>>;
  subjects: <T = Promise<AsyncIterator<SubjectSubscription>>>(args?: {
    where?: SubjectWhereInput;
    orderBy?: SubjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  starList: <T = Promise<AsyncIterator<ParentSubscription>>>(args?: {
    where?: ParentWhereInput;
    orderBy?: ParentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  avalible: <T = Promise<AsyncIterator<AvalibelTimeSubscription>>>(args?: {
    where?: AvalibelTimeWhereInput;
    orderBy?: AvalibelTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  studentDetail: <T = StudentDetailSubscription>() => T;
  invitations: <T = Promise<AsyncIterator<InvitationSubscription>>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Parent {
  id: ID_Output;
  phone: String;
  name: String;
  address: String;
  email: String;
  UnionID: String;
  authstatus: AuthStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ParentPromise extends Promise<Parent>, Fragmentable {
  id: () => Promise<ID_Output>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  email: () => Promise<String>;
  UnionID: () => Promise<String>;
  authstatus: () => Promise<AuthStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  starList: <T = FragmentableArray<Student>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invitations: <T = FragmentableArray<Invitation>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  publishTerm: <T = FragmentableArray<BasicTermInfo>>(args?: {
    where?: BasicTermInfoWhereInput;
    orderBy?: BasicTermInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ParentSubscription
  extends Promise<AsyncIterator<Parent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phone: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  UnionID: () => Promise<AsyncIterator<String>>;
  authstatus: () => Promise<AsyncIterator<AuthStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  starList: <T = Promise<AsyncIterator<StudentSubscription>>>(args?: {
    where?: StudentWhereInput;
    orderBy?: StudentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invitations: <T = Promise<AsyncIterator<InvitationSubscription>>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  order: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  publishTerm: <T = Promise<AsyncIterator<BasicTermInfoSubscription>>>(args?: {
    where?: BasicTermInfoWhereInput;
    orderBy?: BasicTermInfoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Order {
  order: String;
  status: OrderStatus;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  order: () => Promise<String>;
  stuednt: <T = StudentPromise>() => T;
  parents: <T = ParentPromise>() => T;
  status: () => Promise<OrderStatus>;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  order: () => Promise<AsyncIterator<String>>;
  stuednt: <T = StudentSubscription>() => T;
  parents: <T = ParentSubscription>() => T;
  status: () => Promise<AsyncIterator<OrderStatus>>;
}

export interface StudentDetail {
  selfIntro: String;
  grades: String;
  exprience: String;
  pictrue: String[];
}

export interface StudentDetailPromise
  extends Promise<StudentDetail>,
    Fragmentable {
  selfIntro: () => Promise<String>;
  grades: () => Promise<String>;
  exprience: () => Promise<String>;
  pictrue: () => Promise<String[]>;
}

export interface StudentDetailSubscription
  extends Promise<AsyncIterator<StudentDetail>>,
    Fragmentable {
  selfIntro: () => Promise<AsyncIterator<String>>;
  grades: () => Promise<AsyncIterator<String>>;
  exprience: () => Promise<AsyncIterator<String>>;
  pictrue: () => Promise<AsyncIterator<String[]>>;
}

export interface InvitationConnection {
  pageInfo: PageInfo;
  edges: InvitationEdge[];
}

export interface InvitationConnectionPromise
  extends Promise<InvitationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InvitationEdge>>() => T;
  aggregate: <T = AggregateInvitationPromise>() => T;
}

export interface InvitationConnectionSubscription
  extends Promise<AsyncIterator<InvitationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InvitationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInvitationSubscription>() => T;
}

export interface InvitationEdge {
  node: Invitation;
  cursor: String;
}

export interface InvitationEdgePromise
  extends Promise<InvitationEdge>,
    Fragmentable {
  node: <T = InvitationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InvitationEdgeSubscription
  extends Promise<AsyncIterator<InvitationEdge>>,
    Fragmentable {
  node: <T = InvitationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInvitation {
  count: Int;
}

export interface AggregateInvitationPromise
  extends Promise<AggregateInvitation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInvitationSubscription
  extends Promise<AsyncIterator<AggregateInvitation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LongTermConnection {
  pageInfo: PageInfo;
  edges: LongTermEdge[];
}

export interface LongTermConnectionPromise
  extends Promise<LongTermConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LongTermEdge>>() => T;
  aggregate: <T = AggregateLongTermPromise>() => T;
}

export interface LongTermConnectionSubscription
  extends Promise<AsyncIterator<LongTermConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LongTermEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLongTermSubscription>() => T;
}

export interface LongTermEdge {
  node: LongTerm;
  cursor: String;
}

export interface LongTermEdgePromise
  extends Promise<LongTermEdge>,
    Fragmentable {
  node: <T = LongTermPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LongTermEdgeSubscription
  extends Promise<AsyncIterator<LongTermEdge>>,
    Fragmentable {
  node: <T = LongTermSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLongTerm {
  count: Int;
}

export interface AggregateLongTermPromise
  extends Promise<AggregateLongTerm>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLongTermSubscription
  extends Promise<AsyncIterator<AggregateLongTerm>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ParentConnection {
  pageInfo: PageInfo;
  edges: ParentEdge[];
}

export interface ParentConnectionPromise
  extends Promise<ParentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ParentEdge>>() => T;
  aggregate: <T = AggregateParentPromise>() => T;
}

export interface ParentConnectionSubscription
  extends Promise<AsyncIterator<ParentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ParentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateParentSubscription>() => T;
}

export interface ParentEdge {
  node: Parent;
  cursor: String;
}

export interface ParentEdgePromise extends Promise<ParentEdge>, Fragmentable {
  node: <T = ParentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ParentEdgeSubscription
  extends Promise<AsyncIterator<ParentEdge>>,
    Fragmentable {
  node: <T = ParentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateParent {
  count: Int;
}

export interface AggregateParentPromise
  extends Promise<AggregateParent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateParentSubscription
  extends Promise<AsyncIterator<AggregateParent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ShortTermConnection {
  pageInfo: PageInfo;
  edges: ShortTermEdge[];
}

export interface ShortTermConnectionPromise
  extends Promise<ShortTermConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShortTermEdge>>() => T;
  aggregate: <T = AggregateShortTermPromise>() => T;
}

export interface ShortTermConnectionSubscription
  extends Promise<AsyncIterator<ShortTermConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShortTermEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShortTermSubscription>() => T;
}

export interface ShortTermEdge {
  node: ShortTerm;
  cursor: String;
}

export interface ShortTermEdgePromise
  extends Promise<ShortTermEdge>,
    Fragmentable {
  node: <T = ShortTermPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShortTermEdgeSubscription
  extends Promise<AsyncIterator<ShortTermEdge>>,
    Fragmentable {
  node: <T = ShortTermSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateShortTerm {
  count: Int;
}

export interface AggregateShortTermPromise
  extends Promise<AggregateShortTerm>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShortTermSubscription
  extends Promise<AsyncIterator<AggregateShortTerm>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudentConnection {
  pageInfo: PageInfo;
  edges: StudentEdge[];
}

export interface StudentConnectionPromise
  extends Promise<StudentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudentEdge>>() => T;
  aggregate: <T = AggregateStudentPromise>() => T;
}

export interface StudentConnectionSubscription
  extends Promise<AsyncIterator<StudentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudentSubscription>() => T;
}

export interface StudentEdge {
  node: Student;
  cursor: String;
}

export interface StudentEdgePromise extends Promise<StudentEdge>, Fragmentable {
  node: <T = StudentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudentEdgeSubscription
  extends Promise<AsyncIterator<StudentEdge>>,
    Fragmentable {
  node: <T = StudentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudent {
  count: Int;
}

export interface AggregateStudentPromise
  extends Promise<AggregateStudent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudentSubscription
  extends Promise<AsyncIterator<AggregateStudent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudentDetailConnection {
  pageInfo: PageInfo;
  edges: StudentDetailEdge[];
}

export interface StudentDetailConnectionPromise
  extends Promise<StudentDetailConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudentDetailEdge>>() => T;
  aggregate: <T = AggregateStudentDetailPromise>() => T;
}

export interface StudentDetailConnectionSubscription
  extends Promise<AsyncIterator<StudentDetailConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudentDetailEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudentDetailSubscription>() => T;
}

export interface StudentDetailEdge {
  node: StudentDetail;
  cursor: String;
}

export interface StudentDetailEdgePromise
  extends Promise<StudentDetailEdge>,
    Fragmentable {
  node: <T = StudentDetailPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudentDetailEdgeSubscription
  extends Promise<AsyncIterator<StudentDetailEdge>>,
    Fragmentable {
  node: <T = StudentDetailSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudentDetail {
  count: Int;
}

export interface AggregateStudentDetailPromise
  extends Promise<AggregateStudentDetail>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudentDetailSubscription
  extends Promise<AsyncIterator<AggregateStudentDetail>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubjectConnection {
  pageInfo: PageInfo;
  edges: SubjectEdge[];
}

export interface SubjectConnectionPromise
  extends Promise<SubjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SubjectEdge>>() => T;
  aggregate: <T = AggregateSubjectPromise>() => T;
}

export interface SubjectConnectionSubscription
  extends Promise<AsyncIterator<SubjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SubjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSubjectSubscription>() => T;
}

export interface SubjectEdge {
  node: Subject;
  cursor: String;
}

export interface SubjectEdgePromise extends Promise<SubjectEdge>, Fragmentable {
  node: <T = SubjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SubjectEdgeSubscription
  extends Promise<AsyncIterator<SubjectEdge>>,
    Fragmentable {
  node: <T = SubjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSubject {
  count: Int;
}

export interface AggregateSubjectPromise
  extends Promise<AggregateSubject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubjectSubscription
  extends Promise<AsyncIterator<AggregateSubject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  UnionID: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  UnionID: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  UnionID: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AvalibelTimeSubscriptionPayload {
  mutation: MutationType;
  node: AvalibelTime;
  updatedFields: String[];
  previousValues: AvalibelTimePreviousValues;
}

export interface AvalibelTimeSubscriptionPayloadPromise
  extends Promise<AvalibelTimeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AvalibelTimePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AvalibelTimePreviousValuesPromise>() => T;
}

export interface AvalibelTimeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AvalibelTimeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AvalibelTimeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AvalibelTimePreviousValuesSubscription>() => T;
}

export interface AvalibelTimePreviousValues {
  day: Day;
  detail: DetailTime;
}

export interface AvalibelTimePreviousValuesPromise
  extends Promise<AvalibelTimePreviousValues>,
    Fragmentable {
  day: () => Promise<Day>;
  detail: () => Promise<DetailTime>;
}

export interface AvalibelTimePreviousValuesSubscription
  extends Promise<AsyncIterator<AvalibelTimePreviousValues>>,
    Fragmentable {
  day: () => Promise<AsyncIterator<Day>>;
  detail: () => Promise<AsyncIterator<DetailTime>>;
}

export interface BasicTermInfoSubscriptionPayload {
  mutation: MutationType;
  node: BasicTermInfo;
  updatedFields: String[];
  previousValues: BasicTermInfoPreviousValues;
}

export interface BasicTermInfoSubscriptionPayloadPromise
  extends Promise<BasicTermInfoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BasicTermInfoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BasicTermInfoPreviousValuesPromise>() => T;
}

export interface BasicTermInfoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BasicTermInfoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BasicTermInfoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BasicTermInfoPreviousValuesSubscription>() => T;
}

export interface BasicTermInfoPreviousValues {
  termId: ID_Output;
  pay?: Int;
  childGender: Gender;
  TeacherGender: SelectGender;
  teacherReuqire?: String;
  childStatus?: String;
}

export interface BasicTermInfoPreviousValuesPromise
  extends Promise<BasicTermInfoPreviousValues>,
    Fragmentable {
  termId: () => Promise<ID_Output>;
  pay: () => Promise<Int>;
  childGender: () => Promise<Gender>;
  TeacherGender: () => Promise<SelectGender>;
  teacherReuqire: () => Promise<String>;
  childStatus: () => Promise<String>;
}

export interface BasicTermInfoPreviousValuesSubscription
  extends Promise<AsyncIterator<BasicTermInfoPreviousValues>>,
    Fragmentable {
  termId: () => Promise<AsyncIterator<ID_Output>>;
  pay: () => Promise<AsyncIterator<Int>>;
  childGender: () => Promise<AsyncIterator<Gender>>;
  TeacherGender: () => Promise<AsyncIterator<SelectGender>>;
  teacherReuqire: () => Promise<AsyncIterator<String>>;
  childStatus: () => Promise<AsyncIterator<String>>;
}

export interface InvitationSubscriptionPayload {
  mutation: MutationType;
  node: Invitation;
  updatedFields: String[];
  previousValues: InvitationPreviousValues;
}

export interface InvitationSubscriptionPayloadPromise
  extends Promise<InvitationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InvitationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InvitationPreviousValuesPromise>() => T;
}

export interface InvitationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InvitationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InvitationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InvitationPreviousValuesSubscription>() => T;
}

export interface InvitationPreviousValues {
  id: ID_Output;
  invitor: Invitor;
  status: InvitationStatus;
}

export interface InvitationPreviousValuesPromise
  extends Promise<InvitationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  invitor: () => Promise<Invitor>;
  status: () => Promise<InvitationStatus>;
}

export interface InvitationPreviousValuesSubscription
  extends Promise<AsyncIterator<InvitationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  invitor: () => Promise<AsyncIterator<Invitor>>;
  status: () => Promise<AsyncIterator<InvitationStatus>>;
}

export interface LongTermSubscriptionPayload {
  mutation: MutationType;
  node: LongTerm;
  updatedFields: String[];
  previousValues: LongTermPreviousValues;
}

export interface LongTermSubscriptionPayloadPromise
  extends Promise<LongTermSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LongTermPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LongTermPreviousValuesPromise>() => T;
}

export interface LongTermSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LongTermSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LongTermSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LongTermPreviousValuesSubscription>() => T;
}

export interface LongTermPreviousValues {
  longTermId: ID_Output;
  lessonTime?: Int;
  days?: Int;
}

export interface LongTermPreviousValuesPromise
  extends Promise<LongTermPreviousValues>,
    Fragmentable {
  longTermId: () => Promise<ID_Output>;
  lessonTime: () => Promise<Int>;
  days: () => Promise<Int>;
}

export interface LongTermPreviousValuesSubscription
  extends Promise<AsyncIterator<LongTermPreviousValues>>,
    Fragmentable {
  longTermId: () => Promise<AsyncIterator<ID_Output>>;
  lessonTime: () => Promise<AsyncIterator<Int>>;
  days: () => Promise<AsyncIterator<Int>>;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface OrderPreviousValues {
  order: String;
  status: OrderStatus;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  order: () => Promise<String>;
  status: () => Promise<OrderStatus>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  order: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<OrderStatus>>;
}

export interface ParentSubscriptionPayload {
  mutation: MutationType;
  node: Parent;
  updatedFields: String[];
  previousValues: ParentPreviousValues;
}

export interface ParentSubscriptionPayloadPromise
  extends Promise<ParentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ParentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ParentPreviousValuesPromise>() => T;
}

export interface ParentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ParentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ParentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ParentPreviousValuesSubscription>() => T;
}

export interface ParentPreviousValues {
  id: ID_Output;
  phone: String;
  name: String;
  address: String;
  email: String;
  UnionID: String;
  authstatus: AuthStatus;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ParentPreviousValuesPromise
  extends Promise<ParentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  address: () => Promise<String>;
  email: () => Promise<String>;
  UnionID: () => Promise<String>;
  authstatus: () => Promise<AuthStatus>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ParentPreviousValuesSubscription
  extends Promise<AsyncIterator<ParentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phone: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  UnionID: () => Promise<AsyncIterator<String>>;
  authstatus: () => Promise<AsyncIterator<AuthStatus>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ShortTermSubscriptionPayload {
  mutation: MutationType;
  node: ShortTerm;
  updatedFields: String[];
  previousValues: ShortTermPreviousValues;
}

export interface ShortTermSubscriptionPayloadPromise
  extends Promise<ShortTermSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShortTermPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShortTermPreviousValuesPromise>() => T;
}

export interface ShortTermSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShortTermSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShortTermSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShortTermPreviousValuesSubscription>() => T;
}

export interface ShortTermPreviousValues {
  shortTermId: ID_Output;
  timeList: DateTimeOutput[];
}

export interface ShortTermPreviousValuesPromise
  extends Promise<ShortTermPreviousValues>,
    Fragmentable {
  shortTermId: () => Promise<ID_Output>;
  timeList: () => Promise<DateTimeOutput[]>;
}

export interface ShortTermPreviousValuesSubscription
  extends Promise<AsyncIterator<ShortTermPreviousValues>>,
    Fragmentable {
  shortTermId: () => Promise<AsyncIterator<ID_Output>>;
  timeList: () => Promise<AsyncIterator<DateTimeOutput[]>>;
}

export interface StudentSubscriptionPayload {
  mutation: MutationType;
  node: Student;
  updatedFields: String[];
  previousValues: StudentPreviousValues;
}

export interface StudentSubscriptionPayloadPromise
  extends Promise<StudentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudentPreviousValuesPromise>() => T;
}

export interface StudentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudentPreviousValuesSubscription>() => T;
}

export interface StudentPreviousValues {
  id: ID_Output;
  UnionID: String;
  openid: String;
  phone: String;
  name: String;
  university: University;
  email: String;
  Gender?: Gender;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  expectPay?: Int;
  authstatus: AuthStatus;
}

export interface StudentPreviousValuesPromise
  extends Promise<StudentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  UnionID: () => Promise<String>;
  openid: () => Promise<String>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  university: () => Promise<University>;
  email: () => Promise<String>;
  Gender: () => Promise<Gender>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  expectPay: () => Promise<Int>;
  authstatus: () => Promise<AuthStatus>;
}

export interface StudentPreviousValuesSubscription
  extends Promise<AsyncIterator<StudentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  UnionID: () => Promise<AsyncIterator<String>>;
  openid: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  university: () => Promise<AsyncIterator<University>>;
  email: () => Promise<AsyncIterator<String>>;
  Gender: () => Promise<AsyncIterator<Gender>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  expectPay: () => Promise<AsyncIterator<Int>>;
  authstatus: () => Promise<AsyncIterator<AuthStatus>>;
}

export interface StudentDetailSubscriptionPayload {
  mutation: MutationType;
  node: StudentDetail;
  updatedFields: String[];
  previousValues: StudentDetailPreviousValues;
}

export interface StudentDetailSubscriptionPayloadPromise
  extends Promise<StudentDetailSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudentDetailPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudentDetailPreviousValuesPromise>() => T;
}

export interface StudentDetailSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudentDetailSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudentDetailSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudentDetailPreviousValuesSubscription>() => T;
}

export interface StudentDetailPreviousValues {
  selfIntro: String;
  grades: String;
  exprience: String;
  pictrue: String[];
}

export interface StudentDetailPreviousValuesPromise
  extends Promise<StudentDetailPreviousValues>,
    Fragmentable {
  selfIntro: () => Promise<String>;
  grades: () => Promise<String>;
  exprience: () => Promise<String>;
  pictrue: () => Promise<String[]>;
}

export interface StudentDetailPreviousValuesSubscription
  extends Promise<AsyncIterator<StudentDetailPreviousValues>>,
    Fragmentable {
  selfIntro: () => Promise<AsyncIterator<String>>;
  grades: () => Promise<AsyncIterator<String>>;
  exprience: () => Promise<AsyncIterator<String>>;
  pictrue: () => Promise<AsyncIterator<String[]>>;
}

export interface SubjectSubscriptionPayload {
  mutation: MutationType;
  node: Subject;
  updatedFields: String[];
  previousValues: SubjectPreviousValues;
}

export interface SubjectSubscriptionPayloadPromise
  extends Promise<SubjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SubjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubjectPreviousValuesPromise>() => T;
}

export interface SubjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubjectPreviousValuesSubscription>() => T;
}

export interface SubjectPreviousValues {
  name: SubjectName;
  level: Level[];
}

export interface SubjectPreviousValuesPromise
  extends Promise<SubjectPreviousValues>,
    Fragmentable {
  name: () => Promise<SubjectName>;
  level: () => Promise<Level[]>;
}

export interface SubjectPreviousValuesSubscription
  extends Promise<AsyncIterator<SubjectPreviousValues>>,
    Fragmentable {
  name: () => Promise<AsyncIterator<SubjectName>>;
  level: () => Promise<AsyncIterator<Level[]>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  UnionID: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  UnionID: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  UnionID: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "AuthStatus",
    embedded: false
  },
  {
    name: "AvalibelTime",
    embedded: false
  },
  {
    name: "BasicTermInfo",
    embedded: false
  },
  {
    name: "Day",
    embedded: false
  },
  {
    name: "DetailTime",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "Invitation",
    embedded: false
  },
  {
    name: "InvitationStatus",
    embedded: false
  },
  {
    name: "Invitor",
    embedded: false
  },
  {
    name: "Level",
    embedded: false
  },
  {
    name: "LongTerm",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "OrderStatus",
    embedded: false
  },
  {
    name: "Parent",
    embedded: false
  },
  {
    name: "SelectGender",
    embedded: false
  },
  {
    name: "ShortTerm",
    embedded: false
  },
  {
    name: "Student",
    embedded: false
  },
  {
    name: "StudentDetail",
    embedded: false
  },
  {
    name: "Subject",
    embedded: false
  },
  {
    name: "SubjectName",
    embedded: false
  },
  {
    name: "University",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
